{"version":3,"file":"compomint.esm.min.js","sources":["../src/utils.ts","../src/compomint-core.ts","../src/default-template-config.ts","../src/built-in-templates.ts"],"sourcesContent":["\nconst firstElementChild = function (ele: Element | DocumentFragment): Element | null {\n  if (ele.firstElementChild) return ele.firstElementChild;\n  const children = ele.childNodes;\n  for (let i = 0, size = children.length; i < size; i++) {\n    if (children[i] instanceof Element) {\n      return children[i] as Element;\n    }\n  }\n  return null;\n};\n\nconst childNodeCount = function (ele: Element | DocumentFragment): number {\n  return (\n    ele.childElementCount ||\n    Array.prototype.filter.call(ele.childNodes, function (child: Node) {\n      return child instanceof Node;\n    }).length\n  );\n};\n\nconst childElementCount = function (ele: Element | DocumentFragment): number {\n  return (\n    ele.childElementCount ||\n    Array.prototype.filter.call(ele.childNodes, function (child: Node) {\n      return child instanceof Element;\n    }).length\n  );\n};\n\nconst cleanNode = function (node: Node): void {\n  for (let n = 0; n < node.childNodes.length; n++) {\n    const child = node.childNodes[n];\n    if (\n      child.nodeType === 8 || // Comment node\n      (child.nodeType === 3 && !/\\S/.test(child.nodeValue || '')) // Text node with only whitespace\n    ) {\n      node.removeChild(child);\n      n--; // Adjust index after removal\n    } else if (child.nodeType === 1) {\n      // Element node\n      cleanNode(child); // Recurse\n    }\n  }\n};\n\nconst domParser = new DOMParser();\nconst stringToElement = function (str: string | number): Node {\n  if (typeof str === 'number' || !isNaN(Number(str))) {\n    return document.createTextNode(String(str));\n  } else if (typeof str === 'string') {\n    try {\n      const doc = domParser.parseFromString(str, \"text/html\");\n      const body = doc.body;\n      if (body.childNodes.length === 1) {\n        return body.firstChild!;\n      } else {\n        const fragment = document.createDocumentFragment();\n        while (body.firstChild) {\n          fragment.appendChild(body.firstChild);\n        }\n        return fragment;\n      }\n    } catch (e) {\n      return document.createTextNode(str);\n    }\n  } else {\n    return document.createTextNode('');\n  }\n};\n\nconst isPlainObject = function (value: unknown) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport {\n  firstElementChild,\n  childNodeCount,\n  childElementCount,\n  cleanNode,\n  stringToElement,\n  isPlainObject,\n};\n","/*\n * Copyright (c) 2025-present, Choi Sungho\n * Code released under the MIT license\n */\n\nimport { CompomintGlobal, ComponentScope, LazyScope, RenderingFunction, TemplateConfig, TemplateMeta, TemplateRule, Tools, TemplateElement } from \"./type\";\nimport { defaultTemplateConfig } from \"./default-template-config\";\nimport { applyBuiltInTemplates } from \"./built-in-templates\"\nimport {\n  firstElementChild,\n  childElementCount,\n  cleanNode,\n} from \"./utils\";\n\n\n// Polyfill for Object.assign\nif (typeof Object.assign != \"function\") {\n  Object.defineProperty(Object, \"assign\", {\n    value: function assign(target: any, ...params: any[]) {\n      if (target == null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n      }\n      const to = Object(target);\n      for (let index = 0, length = params.length; index < length; index++) {\n        const nextSource = params[index];\n        if (nextSource != null) {\n          for (let nextKey in nextSource) {\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    },\n    writable: true,\n    configurable: true,\n  });\n}\n\n// Polyfill for ChildNode.remove\n(function (arr: any[]) {\n  arr.forEach(function (item) {\n    if (!item || item.hasOwnProperty(\"remove\")) {\n      return;\n    }\n    Object.defineProperty(item, \"remove\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function remove() {\n        if (this.parentNode !== null) {\n          this.parentNode.removeChild(this);\n        }\n      },\n    });\n  });\n})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);\n\n// Polyfill for Node.isConnected\n(function (supported: boolean) {\n  if (supported) return;\n  Object.defineProperty(window.Node.prototype, \"isConnected\", {\n    get: function (): boolean {\n      return document.body.contains(this);\n    },\n  });\n})(\"isConnected\" in window.Node.prototype);\n\nconst compomint = ({} as CompomintGlobal);\nconst tmpl = {} as Record<string, any>;\nconst tools = (compomint.tools = compomint.tools || {} as Tools);\nconst configs = (compomint.configs = Object.assign({ printExecTime: false, debug: false, throwError: true }, compomint.configs));\nconst cachedTmpl = (compomint.tmplCache = compomint.tmplCache || new Map<string, TemplateMeta>());\nif (!cachedTmpl.has(\"anonymous\")) {\n  cachedTmpl.set(\"anonymous\", { elements: new Set() } as TemplateMeta); // Cast to TemplateMeta\n}\nconst isSupportTemplateTag = \"content\" in document.createElement(\"template\");\n\nconst noMatch = /(.)^/;\nconst escapes: Record<string, string> = {\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\",\n  \"\\r\": \"\\\\r\",\n  \"\\n\": \"\\\\n\",\n  \"\\t\": \"\\\\t\",\n  \"\\u2028\": \"\\u2028\",\n  \"\\u2029\": \"\\u2029\",\n  \"><\": \"><\",\n  \"<\": \"<\",\n  \">\": \">\",\n};\n\nconst escaper = /\\>( |\\n)+\\<|\\>( |\\n)+|( |\\n)+\\<|\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n// set default template config\ncompomint.templateConfig = defaultTemplateConfig(configs, compomint);\n\nconst escapeHtml = (function () {\n  const escapeMap: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\", // Use HTML entity for single quote\n    \"`\": \"&#x60;\", // Use HTML entity for backtick\n    //\"\\n\": \"&#10;\", // Keep newline escaping if needed, otherwise remove\n  };\n\n  const unescapeMap: Record<string, string> = Object.fromEntries(Object.entries(escapeMap).map(([key, value]) => [value, key]));\n\n  const createEscaper = function (map: Record<string, string>): (str: string) => string {\n    const escaper = function (match: string): string {\n      return map[match];\n    };\n    const source = `(?:${Object.keys(map).join(\"|\").replace(/\\\\/g, '\\\\\\\\')})`; // Escape backslashes if any keys have them\n    const testRegexp = RegExp(source);\n    const replaceRegexp = RegExp(source, \"g\");\n    return function (string: string | null | undefined): string {\n      string = string == null ? \"\" : `${string}`;\n      return testRegexp.test(string)\n        ? string.replace(replaceRegexp, escaper)\n        : string;\n    };\n  };\n\n  return {\n    escape: createEscaper(escapeMap),\n    unescape: createEscaper(unescapeMap),\n  };\n})();\ntools.escapeHtml = escapeHtml;\n\nconst matcherFunc = function (templateRules: Record<string, TemplateRule>): {\n  templateRules: Record<string, TemplateRule>;\n  pattern: RegExp;\n  exec: ((...args: any[]) => string)[];\n  lazyExecKeys: string[];\n  lazyExec: Record<string, (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element) => void>;\n  lazyScopeSeed: string;\n} {\n  const patternArray: string[] = [];\n  const execArray: ((...args: any[]) => string)[] = [];\n  const lazyExecMap: Record<string, (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element) => void> = {};\n  const lazyScopeSeed: Record<string, any[]> = {};\n\n  Object.keys(templateRules).forEach(function (key) {\n    const templateRule = templateRules[key] as TemplateRule | any; // Type assertion\n    if (templateRule && typeof templateRule === 'object' && templateRule.pattern instanceof RegExp && typeof templateRule.exec === 'function') {\n      patternArray.push((templateRule.pattern || noMatch).source);\n      execArray.push(templateRule.exec);\n    }\n    if (templateRule && typeof templateRule === 'object' && typeof templateRule.lazyExec === 'function') {\n      const arrayKey = `${key}Array`;\n      lazyExecMap[arrayKey] = templateRule.lazyExec;\n      lazyScopeSeed[arrayKey] = [];\n    }\n  });\n  return {\n    templateRules: templateRules,\n    pattern: new RegExp(patternArray.join(\"|\"), \"g\"),\n    exec: execArray,\n    lazyExecKeys: Object.keys(lazyScopeSeed),\n    lazyExec: lazyExecMap,\n    lazyScopeSeed: JSON.stringify(lazyScopeSeed),\n  };\n};\n\nconst escapeFunc = function (match: string): string {\n  return escapes[match] || escapes[match.replace(/[ \\n]/g, \"\")] || \"\";\n};\n\nconst defaultMatcher = matcherFunc(compomint.templateConfig.rules);\n\nconst templateParser = function (tmplId: string, text: string, matcher: ReturnType<typeof matcherFunc>): string {\n  if (configs.printExecTime) console.time(`tmpl: ${tmplId}`);\n\n  let index = 0;\n  let source = \"\";\n\n  text.replace(matcher.pattern, function (...params: any[]): string {\n    const match: string = params[0];\n    const offset: number = params[params.length - 2];\n\n    source += text.slice(index, offset).replace(escaper, escapeFunc);\n\n    let selectedMatchContent: string | undefined;\n    let matchIndex: number | null = null;\n\n    params.slice(1, -2).some(function (value: any, idx: number) {\n      if (value !== undefined) {\n        selectedMatchContent = value;\n        matchIndex = idx;\n        return true;\n      }\n      return false;\n    });\n\n    if (selectedMatchContent !== undefined && matchIndex !== null) {\n      try {\n        source += matcher.exec[matchIndex].call(matcher.templateRules, selectedMatchContent, tmplId);\n      } catch (e: any) {\n        console.error(`Error executing template rule index ${matchIndex} for match \"${selectedMatchContent}\" in template \"${tmplId}\":`, e);\n        if (configs.throwError) throw e;\n        source += '';\n      }\n    } else {\n      source += match.replace(escaper, escapeFunc);\n    }\n\n    index = offset + match.length;\n    return match;\n  });\n\n  source += text.slice(index).replace(escaper, escapeFunc);\n\n  if (configs.printExecTime) console.timeEnd(`tmpl: ${tmplId}`);\n  return source;\n};\n\n\nconst templateBuilder = (compomint.template = function compomint_templateBuilder(\n  tmplId: string,\n  templateText: string,\n  customTemplateConfig?: Partial<TemplateConfig>\n): RenderingFunction {\n  let templateConfig = compomint.templateConfig;\n  let matcher = defaultMatcher;\n\n  if (customTemplateConfig) {\n    templateConfig = Object.assign({}, compomint.templateConfig, customTemplateConfig);\n    matcher = matcherFunc(templateConfig.rules);\n  }\n\n  const source = `\n/* tmplId: ${tmplId} */\n//# sourceURL=http://tmpl//${tmplId.split(\"-\").join(\"//\")}.js\nif (__debugger) {\ndebugger;\n}\nlet __p='';\n__p+='${templateParser(tmplId, templateText, matcher)}';\nreturn __p;`;\n\n  let sourceGenFunc: Function | null = null;\n\n  try {\n    sourceGenFunc = new Function(\n      templateConfig.keys.dataKeyName as string,\n      templateConfig.keys.statusKeyName as string,\n      templateConfig.keys.componentKeyName as string,\n      templateConfig.keys.i18nKeyName as string,\n      \"compomint\",\n      \"tmpl\",\n      \"__lazyScope\",\n      \"__debugger\",\n      source\n    );\n  } catch (e: any) {\n    if (configs.throwError) {\n      console.error(`Template compilation error in \"${tmplId}\", ${e.name}: ${e.message}`);\n      try { // Attempt re-run for potential browser debugging\n        new Function(\n          templateConfig.keys.dataKeyName as string, templateConfig.keys.statusKeyName as string, templateConfig.keys.componentKeyName as string,\n          templateConfig.keys.i18nKeyName as string, \"compomint\", \"tmpl\", \"__lazyScope\", \"__debugger\", source\n        );\n      } catch { /* Ignore re-run error */ }\n      throw e;\n    } else {\n      return (() => ({} as ComponentScope)); // Return a dummy function if not throwing\n    }\n  }\n\n  const renderingFunc: RenderingFunction = function compomint_renderingFuncBuilder(...params): ComponentScope {\n    let data: Record<string, any>;\n    let wrapperElement: Element | undefined;\n    let callback: ((component: ComponentScope) => void) | undefined;\n    let baseComponent: Partial<ComponentScope> | undefined;\n\n    // Argument parsing logic\n    const firstArg = params[0];\n    if (firstArg && typeof firstArg === 'object' && (firstArg.$wrapperElement || firstArg.$callback || firstArg.$baseComponent)) {\n      data = { ...firstArg }; // Clone data object\n      wrapperElement = data.$wrapperElement; delete data.$wrapperElement;\n      callback = data.$callback; delete data.$callback;\n      baseComponent = data.$baseComponent; delete data.$baseComponent;\n    } else {\n      data = firstArg;\n      if (typeof params[1] === 'function') {\n        wrapperElement = undefined;\n        callback = params[1] as ((component: ComponentScope) => void);\n        baseComponent = params[2];\n      } else {\n        wrapperElement = params[1];\n        callback = params[2];\n        baseComponent = params[3];\n      }\n    }\n\n\n    const dataKeyName = templateConfig.keys.dataKeyName as string;\n    const statusKeyName = templateConfig.keys.statusKeyName as string;\n    const lazyScope: LazyScope = JSON.parse(matcher.lazyScopeSeed);\n\n    const component: ComponentScope = Object.assign(baseComponent || {}, {\n      tmplId: tmplId,\n      element: null as any, // Initialize element\n      status: (baseComponent && baseComponent.status) || {}, // Ensure status exists\n      replace: function (newComponent: ComponentScope | Element): void {\n        const self = this as ComponentScope;\n        if (!self.element || !(self.element instanceof Node) || !self.element.parentElement) {\n          if (configs.debug) console.warn(`Cannot replace template \"${tmplId}\": element not in DOM.`);\n          return;\n        }\n        self.element.parentElement.replaceChild(\n          (newComponent as ComponentScope).element || newComponent as Element,\n          self.element as Node\n        );\n      },\n      remove: function (spacer: boolean = false): Element | TemplateElement | Comment | DocumentFragment {\n        const self = this as ComponentScope;\n        if (self.beforeRemove) { try { self.beforeRemove(); } catch (e) { console.error(\"Error in beforeRemove:\", e); } }\n\n        // Remote event event listener \n        // Iterate through all event handlers stored in lazyScope.eventArray\n        if (lazyScope.eventArray) {\n          lazyScope.eventArray.forEach(function (event) {\n            // For each event entry, iterate through its associated event listeners\n            event.forEach(function (selectedEvent: Record<string, any>) {\n              if (selectedEvent.element) {\n                if (typeof selectedEvent.eventFunc === 'function') {\n                  selectedEvent.element.removeEventListener('click', selectedEvent.eventFunc as EventListenerOrEventListenerObject); // Remove click event listener\n                } else {\n                  Object.keys(selectedEvent.eventFunc).forEach(function (eventType) {\n                    selectedEvent.element.removeEventListener(eventType, (selectedEvent.eventFunc as Record<string, EventListenerOrEventListenerObject>)[eventType]);\n                  });\n                }\n                Object.keys(selectedEvent).forEach(key => delete selectedEvent[key]);\n              }\n              // Clear the selectedEvent object to release references\n            });\n          });\n        }\n\n        const parent = (self.element instanceof Node) ? self.element.parentElement : null;\n        const removedElement: Element | TemplateElement | Comment | DocumentFragment = self.element; // Store reference\n\n        if (parent) {\n          if (spacer) {\n            const dumy = document.createElement(\"template\");\n            parent.replaceChild(dumy, self.element as Node);\n            self.element = dumy; // Update scope's element reference\n          } else {\n            parent.removeChild(self.element as Node);\n          }\n        } else if (configs.debug) {\n          console.warn(`Cannot remove template \"${tmplId}\": element not in DOM.`);\n        }\n\n        if (self.afterRemove) { try { self.afterRemove(); } catch (e) { console.error(\"Error in afterRemove:\", e); } }\n        return removedElement;\n      },\n      appendTo: function (parentElement: Element): ComponentScope {\n        const self = this as ComponentScope;\n        if (self.beforeAppendTo) { try { self.beforeAppendTo(); } catch (e) { console.error(\"Error in beforeAppendTo:\", e); } }\n\n        if (parentElement && self.element instanceof Node) {\n          parentElement.appendChild(self.element);\n        } else if (configs.debug) {\n          console.warn(`Cannot append template \"${tmplId}\": parentElement or scope.element is missing or not a Node.`);\n        }\n\n        if (self.afterAppendTo) {\n          setTimeout(() => { try { self.afterAppendTo!(); } catch (e) { console.error(\"Error in afterAppendTo:\", e); } }, 0);\n        }\n        return self;\n      },\n      release: function (): void { /* Implementation below */ },\n      render: function (newData: Record<string, any>): ComponentScope { /* Implementation below */ return this; },\n      refresh: function (reflashData: Record<string, any>): ComponentScope { /* Implementation below */ return this; },\n      reflash: function (reflashData: Record<string, any>): ComponentScope { /* Implementation below */ return this; },\n    } as ComponentScope); // Cast to ComponentScope\n\n    if (!component._id) {\n      component._id = tools.genId(tmplId);\n    }\n    component[dataKeyName] = data;\n    if (component[statusKeyName] == undefined) {\n      component[statusKeyName] = {};\n    }\n\n    const hasParent = wrapperElement instanceof Element;\n    const temp = document.createElement(\"template\");\n\n    if (configs.printExecTime) console.time(`render: ${tmplId}`);\n\n    let returnTarget: Node | null = null;\n    let renderedHTML: string | null = null;\n    try {\n      renderedHTML = !data\n        ? `<template data-co-empty-template=\"${tmplId}\"></template>`\n        : sourceGenFunc!.call( // Use non-null assertion\n          wrapperElement || null,\n          data,\n          component[statusKeyName],\n          component,\n          compomint.i18n[tmplId],\n          compomint,\n          tmpl,\n          lazyScope,\n          configs.debug // Pass debug flag for __debugger\n        );\n    } catch (e: any) {\n      if (configs.throwError) {\n        console.error(`Runtime error during render of \"${tmplId}\":`, e.message);\n        console.log(\"--- Data ---\", data, \"------------\");\n        try { // Attempt re-run with debugger\n          sourceGenFunc!.call(wrapperElement || null, data, component[statusKeyName], component, compomint.i18n[tmplId], lazyScope, true);\n        } catch { /* Ignore */ }\n        throw e;\n      } else {\n        console.warn(`Render failed for \"${tmplId}\". Returning scope with comment node.`);\n        component.element = document.createComment(`Render Error: ${tmplId}`) as any;\n        return component;\n      }\n    }\n    if (configs.printExecTime) console.timeEnd(`render: ${tmplId}`);\n\n    temp.innerHTML = renderedHTML!;\n    let docFragment: DocumentFragment | Element | TemplateElement = temp.content || temp;\n\n    if ((docFragment as any).tagName == \"TEMPLATE\" && !(temp as any).content) { // Check for IE11 case\n      const children = Array.from(docFragment.childNodes);\n      docFragment = document.createDocumentFragment();\n      children.forEach(child => docFragment.appendChild(child));\n    }\n\n    const lazyExec = matcher.lazyExec;\n    if (data) {\n      matcher.lazyExecKeys.forEach(function (key) {\n\n        if (lazyScope[key] && lazyScope[key].length > 0) {\n          try {\n            lazyExec[key].call(templateConfig.rules[key.slice(0, -5)], data, lazyScope, component, docFragment as DocumentFragment | Element); // Cast needed\n          } catch (e: any) {\n            if (configs.throwError) {\n              console.error(`Error during lazy execution of \"${key}\" for template \"${tmplId}\":`, e);\n              throw e;\n            }\n          }\n        }\n      });\n    }\n\n    if (hasParent && wrapperElement) {\n      while (wrapperElement.firstChild) {\n        wrapperElement.removeChild(wrapperElement.firstChild);\n      }\n      component.wrapperElement = wrapperElement;\n    }\n\n    // Handle shadow DOM creation\n    const shadowStyle = (docFragment as any).querySelector ? (docFragment as any).querySelector(\"style\") : null;\n    if (shadowStyle && (docFragment as any).querySelector) { // Check if querySelector exists\n      const host = document.createElement(tmplId); // Use tmplId as host tag name\n      try {\n        const shadow = host.attachShadow({ mode: \"open\" });\n        while (docFragment.firstChild) {\n          shadow.appendChild(docFragment.firstChild);\n        }\n        docFragment = host; // Replace fragment with the host element\n      } catch (e) {\n        console.error(`Failed to attach shadow DOM for template \"${tmplId}\":`, e);\n        // Proceed without shadow DOM if attachShadow fails\n      }\n    }\n\n\n    if (docFragment.firstChild && docFragment.firstChild.nodeType == 8) {\n      returnTarget = docFragment.firstChild;\n    } else if (childElementCount(docFragment) == 1) {\n      returnTarget = firstElementChild(docFragment);\n      if (hasParent && wrapperElement && returnTarget) {\n        if (component.beforeAppendTo) { try { component.beforeAppendTo(); } catch (e) { console.error(\"Error in beforeAppendTo:\", e); } }\n        wrapperElement.appendChild(returnTarget);\n        if (component.afterAppendTo) { setTimeout(() => { try { component.afterAppendTo!(); } catch (e) { console.error(\"Error in afterAppendTo:\", e); } }, 0); }\n      }\n    } else {\n      if (hasParent && wrapperElement) {\n        if (component.beforeAppendTo) { try { component.beforeAppendTo(); } catch (e) { console.error(\"Error in beforeAppendTo:\", e); } }\n        wrapperElement.appendChild(docFragment);\n        if (component.afterAppendTo) { setTimeout(() => { try { component.afterAppendTo!(); } catch (e) { console.error(\"Error in afterAppendTo:\", e); } }, 0); }\n        returnTarget = wrapperElement;\n      } else {\n        returnTarget = docFragment;\n      }\n    }\n\n    if (data && data.$props && returnTarget instanceof Element) {\n      for (const prop in data.$props) {\n        try {\n          const value = data.$props[prop];\n          if (prop.startsWith('data-')) {\n            const camelCased = prop.substring(5).replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n            (returnTarget as HTMLElement).dataset[camelCased] = String(value);\n          } else if (prop in returnTarget) {\n            (returnTarget as any)[prop] = value;\n          } else {\n            returnTarget.setAttribute(prop, String(value));\n          }\n        } catch (e: any) {\n          console.error(`Error applying prop \"${prop}\" to element in template \"${tmplId}\":`, e);\n        }\n      }\n    }\n\n    if (returnTarget instanceof Node && returnTarget.normalize) {\n      returnTarget.normalize();\n    }\n    if (returnTarget instanceof Node) {\n      cleanNode(returnTarget);\n    }\n    component.element = returnTarget as HTMLElement | TemplateElement; // Assign final element/fragment\n\n    if (tools.liveReloadSupport) {\n      try { tools.liveReloadSupport(component); } catch (e) { console.error(\"Error in liveReloadSupport:\", e); }\n    }\n\n    if (callback) {\n      try {\n        callback.call(wrapperElement || null, component);\n      } catch (e: any) {\n        console.error(`Error in template callback for \"${tmplId}\":`, e);\n        if (configs.throwError) throw e;\n      }\n    }\n\n    // Define Component Methods (Render/Refresh/Release)\n    component.release = function (): void {\n      const self = this as ComponentScope;\n      const props = Object.getOwnPropertyNames(self);\n      const keepProps = [statusKeyName, '_id'];\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i];\n        if (typeof (self as any)[prop] !== 'function' && !keepProps.includes(prop)) {\n          delete (self as any)[prop];\n        }\n      }\n    };\n\n    component.render = function (newData: Record<string, any>): ComponentScope {\n      const currentComponent = this as ComponentScope;\n      const targetElement = currentComponent.element;\n      const parent = (targetElement instanceof Node) ? targetElement.parentElement : null;\n      const wrapper = currentComponent.wrapperElement;\n      const tmplFunc = compomint.tmpl(currentComponent.tmplId);\n\n      if (!tmplFunc) {\n        console.error(`Cannot re-render: Template function for \"${currentComponent.tmplId}\" not found.`);\n        return currentComponent;\n      }\n\n      const hooks = {\n        beforeAppendTo: currentComponent.beforeAppendTo, afterAppendTo: currentComponent.afterAppendTo,\n        beforeRemove: currentComponent.beforeRemove, afterRemove: currentComponent.afterRemove,\n        beforeRefresh: currentComponent.beforeRefresh, afterRefresh: currentComponent.afterRefresh\n      };\n\n      if (currentComponent.beforeRemove) { try { currentComponent.beforeRemove(); } catch (e) { console.error(\"Error in beforeRemove during render:\", e); } }\n\n      let newComponent: ComponentScope;\n      if (wrapper) {\n        newComponent = tmplFunc(newData, wrapper, undefined, currentComponent); // Reuse scope object\n      } else if (parent && targetElement instanceof Node) {\n        newComponent = tmplFunc(newData, undefined, undefined, currentComponent); // Reuse scope object\n        if (newComponent.element instanceof Node) {\n          if (newComponent.beforeAppendTo) { try { newComponent.beforeAppendTo(); } catch (e) { console.error(\"Error in beforeAppendTo during render:\", e); } }\n          parent.replaceChild(newComponent.element, targetElement);\n          if (newComponent.afterAppendTo) { setTimeout(() => { try { newComponent.afterAppendTo!(); } catch (e) { console.error(\"Error in afterAppendTo during render:\", e); } }, 0); }\n        } else if (configs.debug) {\n          console.warn(`Re-render of \"${currentComponent.tmplId}\" resulted in no element or target was missing.`);\n        }\n      } else {\n        // No parent, just create new scope (likely detached)\n        newComponent = tmplFunc(newData, undefined, undefined, currentComponent);\n      }\n\n      if (currentComponent.afterRemove) { try { currentComponent.afterRemove(); } catch (e) { console.error(\"Error in afterRemove during render:\", e); } }\n\n      Object.assign(newComponent, hooks); // Restore hooks\n      return newComponent;\n    };\n\n    component.refresh = function (reflashData: Record<string, any>): ComponentScope {\n      const currentComponent = this as ComponentScope;\n      const currentData = currentComponent[dataKeyName];\n      if (currentComponent.beforeRefresh) { try { currentComponent.beforeRefresh(); } catch (e) { console.error(\"Error in beforeRefresh:\", e); } }\n      const newData = Object.assign({}, currentData || {}, reflashData);\n      const newComponent = currentComponent.render(newData);\n      if (currentComponent.afterRefresh) { try { currentComponent.afterRefresh(); } catch (e) { console.error(\"Error in afterRefresh:\", e); } }\n      return newComponent;\n    };\n\n    component.reflash = component.refresh;\n\n    return component;\n  }; // End of renderingFunc definition\n\n  Object.defineProperty(renderingFunc, \"name\", { value: `render_${tmplId}`, writable: false });\n\n  if (tmplId) {\n    const tmplMeta: TemplateMeta = configs.debug ? {\n      renderingFunc: renderingFunc,\n      source: escapeHtml.escape(`function ${tmplId}_source (${templateConfig.keys.dataKeyName}, ${templateConfig.keys.statusKeyName}, ${templateConfig.keys.componentKeyName}, ${templateConfig.keys.i18nKeyName}, __lazyScope, __debugger) {\\n${source}\\n}`),\n      templateText: escapeHtml.escape(templateText),\n    } : {\n      renderingFunc: renderingFunc,\n    };\n    cachedTmpl.set(tmplId, tmplMeta);\n\n    const tmplIdNames = tmplId.split(\"-\");\n    if (tmplIdNames.length > 1) {\n      const group = tmplIdNames[0];\n      let groupObj = tmpl[group];\n      if (!groupObj) {\n        tmpl[group] = groupObj = {};\n      }\n      const tmplIdSub = tmplIdNames\n        .slice(1)\n        .map((part, index) => index === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1))\n        .join('');\n      groupObj[tmplIdSub] = tmplMeta.renderingFunc;\n    }\n  }\n  return renderingFunc;\n}); // End of templateBuilder\n\ncompomint.remapTmpl = function (json: Record<string, string>): void {\n  Object.keys(json).forEach(function (oldKey: string) {\n    const newKey = json[oldKey];\n    const meta = cachedTmpl.get(oldKey);\n    if (meta) {\n      cachedTmpl.set(newKey, meta);\n      if (configs.debug) console.log(`Remapped template \"${oldKey}\" to \"${newKey}\"`);\n    } else if (configs.debug) {\n      console.warn(`Cannot remap template: Old key \"${oldKey}\" not found in cache.`);\n    }\n  });\n};\n\ncompomint.tmpl = function (tmplId: string): RenderingFunction | null {\n  const tmplMeta = cachedTmpl.get(tmplId);\n  return tmplMeta ? tmplMeta.renderingFunc : null;\n};\n\nconst safeTemplate = function (source: Element | string): Element | TemplateElement {\n  let template: TemplateElement;\n  if (source instanceof Element) {\n    if (source.tagName === 'TEMPLATE') return source as TemplateElement;\n    return source; // Assume it's a container element\n  } else if (typeof source !== 'string') {\n    if (configs.debug) console.warn(\"safeTemplate received non-string/non-element source:\", source);\n    source = '';\n  }\n\n  template = document.createElement(\"template\");\n  if (isSupportTemplateTag) {\n    const encodedSource = source.replace(\n      /<(?!template|\\/template|body|\\/body|html|\\/html|head|\\/head|style|\\/style|script|\\/script|link|\\/link|meta|\\/meta|!--)/gi,\n      \"&lt;\"\n    );\n    template.innerHTML = encodedSource;\n  } else {\n    const encodedSource = source\n      .replace(\n        /<(?!template|\\/template|body|\\/body|html|\\/html|head|\\/head|style|\\/style|script|\\/script|link|\\/link|meta|\\/meta|!--)/gi,\n        \"&lt;\"\n      )\n      .replace(/<template/g, '<script type=\"template\"')\n      .replace(/<\\/template>/g, \"</script>\");\n    template.innerHTML = encodedSource;\n  }\n  return template;\n};\n\nconst addTmpl: CompomintGlobal[\"addTmpl\"] = (compomint.addTmpl = function (tmplId, element, templateConfig) {\n  let templateText = element instanceof Element ? element.innerHTML : String(element);\n  templateText = escapeHtml.unescape(templateText.replace(/<!---|--->/gi, \"\"));\n  return templateBuilder(tmplId, templateText, templateConfig);\n});\n\nconst addTmpls: CompomintGlobal[\"addTmpls\"] = (compomint.addTmpls = function (source, removeInnerTemplate, templateConfig) {\n  if (typeof removeInnerTemplate !== \"boolean\" && templateConfig == undefined) {\n    templateConfig = removeInnerTemplate as Partial<TemplateConfig> | undefined;\n    removeInnerTemplate = false;\n  } else {\n    removeInnerTemplate = !!removeInnerTemplate;\n  }\n\n  const container = safeTemplate(source);\n  const content = (container as TemplateElement).content || container; // Use content if available\n  const tmplNodes = content.querySelectorAll<Element>(\n    'template[id], script[type=\"text/template\"][id], script[type=\"text/compomint\"][id]'\n  );\n\n  tmplNodes.forEach(node => {\n    const tmplId = node.id;\n    if (!tmplId) return;\n\n    if ((node as HTMLElement).dataset.coLoadScript !== undefined) {\n      addTmpl(tmplId, node, templateConfig)({}); // Execute immediately if data-co-load-script\n    } else {\n      addTmpl(tmplId, node, templateConfig);\n    }\n\n    if (removeInnerTemplate && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n  return container;\n});\n\nconst addTmplByUrl: CompomintGlobal[\"addTmplByUrl\"] = (compomint.addTmplByUrl = function compomint_addTmplByUrl(importData, option, callback) {\n  if (!callback && typeof option === \"function\") {\n    callback = option;\n    option = {};\n  }\n\n  const defaultOptions = {\n    loadScript: true, loadStyle: true, loadLink: true, templateConfig: undefined\n  };\n  const mergedOptions = Object.assign({}, defaultOptions, option as Record<string, any>); // Ensure option is object\n\n  const importDataParser = (obj: string | any): { url: string; option: Record<string, any> } | null => {\n    if (typeof obj === \"string\") {\n      return { url: obj, option: mergedOptions };\n    } else if (obj && typeof obj === 'object' && obj.url) {\n      return { url: obj.url, option: Object.assign({}, mergedOptions, obj.option) };\n    } else {\n      console.error(\"Invalid import data format in addTmplByUrl:\", obj);\n      return null;\n    }\n  };\n\n  const appendElements = (elements: NodeListOf<Element> | Element[]): void => {\n    elements.forEach(element => {\n      if (!element) return;\n      if (element.id) {\n        const oldElement = document.getElementById(element.id);\n        if (oldElement) oldElement.parentNode?.removeChild(oldElement);\n      }\n      if (element.tagName === 'SCRIPT' || element.tagName === 'LINK' || element.tagName === 'STYLE') {\n        document.head.appendChild(element);\n      } else {\n        document.body.appendChild(element);\n      }\n    });\n  };\n\n  const importFunc = (source: string, currentOption: Record<string, any>): void => {\n    const templateContainer = safeTemplate(source);\n    addTmpls(templateContainer, false, currentOption.tmplSettings);\n    const content = (templateContainer as TemplateElement).content || templateContainer;\n\n    if (currentOption.loadLink) {\n      const links = content.querySelectorAll<HTMLLinkElement>('link[rel=\"stylesheet\"]');\n      appendElements(links);\n    }\n    if (currentOption.loadStyle) {\n      const styles = content.querySelectorAll<HTMLStyleElement>(\"style[id]\");\n      appendElements(styles);\n    }\n    if (currentOption.loadScript) {\n      const scripts = content.querySelectorAll<HTMLScriptElement>(\n        'script:not([type]), script[type=\"text/javascript\"], script[type=\"module\"]'\n      );\n      const executableScripts = Array.from(scripts)\n        .filter(node => {\n          let parent = node.parentNode;\n          while (parent) {\n            if (parent.nodeName === 'TEMPLATE' || (parent.nodeName === 'SCRIPT' && (parent as HTMLScriptElement).type.includes('template'))) return false;\n            parent = parent.parentNode;\n          }\n          return true;\n        })\n        .map(node => {\n          const scriptElm = document.createElement(\"script\");\n          node.getAttributeNames().forEach(name => scriptElm.setAttribute(name, node.getAttribute(name)!));\n          if (node.innerHTML) scriptElm.textContent = node.innerHTML;\n          return scriptElm;\n        });\n      appendElements(executableScripts);\n    }\n  };\n\n  const loadResource = (dataItem: string | any): Promise<void> => {\n    return new Promise((resolve, reject) => {\n      const parsedData = importDataParser(dataItem);\n      if (!parsedData) {\n        resolve(); // Resolve immediately for invalid data\n        return;\n      }\n      const src = parsedData.url;\n      const currentOption = parsedData.option;\n\n      if (src.endsWith(\".js\")) {\n        const script = genElement(\"script\", { async: true, src: src }) as HTMLScriptElement;\n        //script.onload = () => resolve();\n        script.onerror = () => { console.error(`Failed to load script: ${src}`); }; // Resolve even on error\n        document.head.appendChild(script);\n        resolve();\n      } else if (src.endsWith(\".css\")) {\n        const link = genElement(\"link\", { type: \"text/css\", rel: \"stylesheet\", href: src }) as HTMLLinkElement;\n        //link.onload = () => resolve(); // CSS load might be unreliable\n        link.onerror = () => { console.error(`Failed to load stylesheet: ${src}`); }; // Resolve even on error\n        document.head.appendChild(link);\n        resolve();\n        // Resolve slightly early for CSS? Or rely on potential browser caching?\n        // For simplicity, let's resolve on load/error.\n      } else {\n        requestFunc(src, null, (source, status) => {\n          if (status === 200 || status === 0) {\n            try {\n              importFunc(source!, currentOption); // Use non-null assertion for source\n            } catch (e) {\n              console.error(`Error processing imported HTML from ${src}:`, e);\n            }\n          } else {\n            console.error(`Failed to fetch template file: ${src} (Status: ${status})`);\n          }\n          resolve(); // Resolve after processing or error\n        });\n      }\n    });\n  };\n\n  const finalCallback = callback || (() => { }); // Ensure callback is a function\n\n  if (Array.isArray(importData)) {\n    if (importData.length === 0) {\n      finalCallback();\n      return;\n    }\n    Promise.all(importData.map(loadResource)).then(finalCallback as ((value: void[]) => void[] | PromiseLike<void[]>)).catch(err => {\n      console.error(\"Error loading resources in addTmplByUrl:\", err);\n      finalCallback(); // Call callback even if some resources failed\n    });\n  } else {\n    loadResource(importData).then(finalCallback as ((value: void) => void[] | PromiseLike<void[]>)).catch(err => {\n      console.error(\"Error loading resource in addTmplByUrl:\", err);\n      finalCallback(); // Call callback even if resource failed\n    });\n  }\n});\n\nconst requestFunc = function (url: string, option: RequestInit | null, callback: (responseText: string | null, status: number, xhr: XMLHttpRequest) => void): void {\n  const xmlhttp = new XMLHttpRequest();\n\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n      if (xmlhttp.status == 200 || xmlhttp.status === 0) {\n        callback(xmlhttp.responseText, xmlhttp.status, xmlhttp);\n      } else {\n        if (xmlhttp.status == 404) console.error(`Error 404: Not Found - ${url}`);\n        else if (xmlhttp.status >= 400) console.error(`HTTP Error ${xmlhttp.status} for ${url}`);\n        else console.error(`Request failed for ${url}`, xmlhttp.statusText);\n        callback(null, xmlhttp.status, xmlhttp);\n      }\n    }\n  };\n\n  xmlhttp.onerror = function () {\n    console.error(`Network error requesting ${url}`);\n    callback(null, 0, xmlhttp);\n  };\n  xmlhttp.ontimeout = function () {\n    console.error(`Request timed out for ${url}`);\n    callback(null, 408, xmlhttp);\n  };\n\n  try {\n    const method = (option && (option as any).method) || \"GET\";\n    xmlhttp.open(method, url, true);\n\n    if (option) {\n      if ((option as any).timeout) xmlhttp.timeout = (option as any).timeout;\n      if (option.headers) {\n        Object.entries(option.headers).forEach(([key, value]) => {\n          xmlhttp.setRequestHeader(key, value);\n        });\n      }\n      xmlhttp.send(option.body as any || null);\n    } else {\n      xmlhttp.send();\n    }\n  } catch (e: any) {\n    console.error(`Error sending request to ${url}:`, e);\n    callback(null, 0, xmlhttp);\n  }\n};\n\ncompomint.i18n = {};\n\ncompomint.addI18n = function (fullKey: string, i18nObj: Record<string, any>): void {\n  if (!fullKey || typeof fullKey !== 'string' || !i18nObj || typeof i18nObj !== 'object') {\n    console.error(\"Invalid arguments for addI18n:\", fullKey, i18nObj);\n    return;\n  }\n\n  const langKeyNames = fullKey.split(\".\");\n  let target: any = compomint.i18n;\n  const keyLength = langKeyNames.length - 1;\n\n  langKeyNames.forEach(function (key: string, i: number) {\n    if (!key) return;\n\n    if (keyLength === i) {\n      if (!target[key]) {\n        target[key] = function (defaultText?: string): string {\n          const lang = document.documentElement.lang || 'en';\n          let label = i18nObj[lang];\n          if (label === undefined || label === null) {\n            label = defaultText;\n            if (configs.debug) console.warn(`i18n: Label key [\"${fullKey}\"] for lang \"${lang}\" is missing. Using default: \"${defaultText}\"`);\n          }\n          return label !== undefined && label !== null ? String(label) : '';\n        };\n      }\n      // Handle nested objects within the language definitions\n      Object.keys(i18nObj)\n        .filter((lang) => i18nObj[lang] instanceof Object && !Array.isArray(i18nObj[lang])) // Check for plain objects\n        .forEach((subKey) => {\n          compomint.addI18n(fullKey + \".\" + subKey, i18nObj[subKey]);\n          // delete i18nObj[subKey]; // Avoid deleting if it's also a language key\n        });\n    } else {\n      if (!target[key]) {\n        target[key] = {};\n      }\n      target = target[key];\n    }\n  });\n};\n\ncompomint.addI18ns = function (i18nObjs: Record<string, any>): void {\n  Object.keys(i18nObjs || {}).forEach(function (key) {\n    compomint.addI18n(key, i18nObjs[key]);\n  });\n};\n\nlet elementCount = 0;\ntools.genId = function (tmplId: string): string {\n  elementCount++;\n  return tmplId + elementCount;\n};\n\nconst genElement = (tools.genElement = function (\n  tagName: string,\n  attrs: Record<string, any> | string | Node | (string | Node)[] = {},\n  ...children: (string | Node)[]\n): Element {\n  const element = document.createElement(tagName);\n  let actualAttrs: Record<string, any> = {};\n\n  if (typeof attrs === 'string') {\n    children.unshift(attrs); // Prepend string as first child\n  } else if (attrs instanceof Node) {\n    children.unshift(attrs); // Prepend Node as first child\n  } else if (Array.isArray(attrs)) {\n    children = attrs.concat(children); // Concatenate arrays\n  } else {\n    actualAttrs = attrs; // It's an attributes object\n  }\n\n  // Set attributes/properties\n  Object.keys(actualAttrs).forEach(function (key) {\n    const value = actualAttrs[key];\n    const propName = key === 'class' ? 'className' : key;\n\n    try {\n      if (key === 'style' && typeof value === 'object' && value !== null) {\n        Object.assign(element.style, value); // Assign style object\n      } else if (key === 'dataset' && typeof value === 'object' && value !== null) {\n        Object.assign((element as HTMLElement).dataset, value); // Assign dataset object\n      } else if (key.startsWith('on') && typeof value === 'function') {\n        // Directly assign event handlers like onclick, onmouseover\n        (element as any)[key.toLowerCase()] = value;\n      } else if (propName in element) {\n        (element as any)[propName] = value;\n      } else {\n        element.setAttribute(key, String(value));\n      }\n    } catch (e: any) {\n      console.error(`Error setting attribute/property \"${key}\" on <${tagName}>:`, e);\n    }\n  });\n\n  // Append children\n  children.forEach(child => {\n    if (typeof child === 'string') {\n      element.appendChild(document.createTextNode(child));\n    } else if (child instanceof Node) {\n      element.appendChild(child);\n    }\n  });\n  return element;\n});\n\ntools.props = function (...propsObjects: Record<string, any>[]): string {\n  if (!propsObjects || propsObjects.length === 0) return \"\";\n  const mergedProps = Object.assign({}, ...propsObjects);\n  const propStrArray: string[] = [];\n  Object.keys(mergedProps).forEach(function (key) {\n    const value = mergedProps[key];\n    if (value || value === 0) {\n      const escapedValue = String(value).replace(/\"/g, '&quot;');\n      propStrArray.push(`${key}=\"${escapedValue}\"`);\n    }\n  });\n  return propStrArray.join(\" \");\n};\n\n// Add built-in template\napplyBuiltInTemplates(addTmpl);\n\n\nexport { compomint, tmpl, CompomintGlobal };","import { ComponentScope, LazyScope, TemplateConfig, TemplateRule, TemplateElement, CompomintConfigs, CompomintGlobal } from \"./type\";\n\nimport {\n  firstElementChild,\n  childElementCount,\n  stringToElement,\n  isPlainObject,\n} from \"./utils\";\n\n// \n// Default template settings\n//\nconst defaultTemplateConfig = (configs: CompomintConfigs, compomint: CompomintGlobal): TemplateConfig => ({\n  rules: {\n    style: {\n      pattern: /(\\<style id=[\\s\\S]+?\\>[\\s\\S]+?\\<\\/style\\>)/g,\n      exec: function (style): string {\n        // Create a temporary element to parse the style tag\n        const dumy = document.createElement(\"template\");\n        dumy.innerHTML = style;\n        const styleNode = (dumy.content || dumy).querySelector(\"style\");\n        if (!styleNode || !styleNode.id) return \"\"; // Skip if no style node or ID\n        const oldStyleNode = document.getElementById(styleNode.id);\n        if (oldStyleNode) oldStyleNode.parentNode?.removeChild(oldStyleNode);\n        document.head.appendChild(styleNode);\n        return \"\";\n      },\n    },\n    commentArea: {\n      pattern: /##\\*([\\s\\S]+?)##/g,\n      exec: function (commentArea: string): string {\n        // Return an empty string to remove the comment block\n        return ``;\n      },\n    },\n    preEvaluate: {\n      pattern: /##!([\\s\\S]+?)##/g,\n      exec: function (preEvaluate: string, tmplId: string): string {\n        try {\n          // Execute the code in a new function context\n          new Function(\"tmplId\", preEvaluate)(tmplId);\n        } catch (e: any) {\n          if (configs.throwError) {\n            console.error(`Template preEvaluate error in \"${tmplId}\", ${e.name}: ${e.message}`);\n            throw e;\n          } else {\n            console.warn(`Template preEvaluate error in \"${tmplId}\", ${e.name}: ${e.message}`);\n          }\n        }\n        return ``;\n      },\n    },\n    interpolate: {\n      pattern: /##=([\\s\\S]+?)##/g,\n      exec: function (interpolate: string): string {\n        // Construct JavaScript code to interpolate the value\n        const interpolateSyntax = `typeof (interpolate)=='function' ? (interpolate)() : (interpolate)`;\n        return (`';\\n(() => {let __t, interpolate=${interpolate};\\n__p+=((__t=(${interpolateSyntax}))==null ? '' : String(__t) );})();\\n__p+='`); // Ensure string conversion\n      },\n    },\n    escape: {\n      pattern: /##-([\\s\\S]+?)##/g,\n      exec: function (escape: string): string {\n        const escapeSyntax = `compomint.tools.escapeHtml.escape(typeof (escape)=='function' ? (escape)() : (escape))`;\n        // Construct JavaScript code to escape HTML characters in the value\n        return (`';\\n(() => {let __t, escape=${escape};\\n__p+=((__t=(${escapeSyntax}))==null ? '' : String(__t) );})();\\n__p+='`); // Ensure string conversion before escape\n      },\n    },\n    elementProps: {\n      pattern: /data-co-props=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (props: string): string {\n        const source = `';\\nconst eventId = (__lazyScope.elementPropsArray.length);\\n__p+='data-co-props=\"'+eventId+'\"';\\n\n__lazyScope.elementPropsArray[eventId] = ${props};\\n__p+='`; // Store props in lazy scope\n        return source;\n      },\n      lazyExec: function (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element): void {\n        // Iterate over stored props and apply them to elements\n        lazyScope.elementPropsArray.forEach(function (props: Record<string, any> | null, eventId: number) {\n          if (!props) return;\n          // Find the element with the corresponding data-co-props attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-props=\"${eventId}\"]`\n          );\n          // Remove the temporary attribute and set the properties\n          if (!$elementTrigger) return;\n          delete ($elementTrigger as HTMLElement).dataset.coProps;\n          Object.keys(props).forEach(function (key: string) {\n            $elementTrigger.setAttribute(key, String(props[key])); // Ensure value is string\n          });\n        });\n      }\n    },\n    namedElement: {\n      pattern: /data-co-named-element=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (key: string): string {\n        const source = `';\\nconst eventId = (__lazyScope.namedElementArray.length);\\n__p+='data-co-named-element=\"'+eventId+'\"';\\n\n__lazyScope.namedElementArray[eventId] = ${key};\\n__p+='`; // Store the key in lazy scope\n        return source;\n      },\n      lazyExec: function (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element): void {\n        // Iterate over stored keys and assign elements to the component\n        lazyScope.namedElementArray.forEach(function (key: string, eventId: number) {\n          // Find the element with the corresponding data-co-named-element attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-named-element=\"${eventId}\"]`\n          );\n          // Assign the element to the component using the key\n          if (!$elementTrigger) {\n            if (configs.debug) console.warn(`Named element target not found for ID ${eventId} in template ${component.tmplId}`);\n            return;\n          }\n          delete ($elementTrigger as HTMLElement).dataset.coNamedElement;\n          component[key] = $elementTrigger;\n        });\n      },\n    },\n    elementRef: {\n      pattern: /data-co-element-ref=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (key: string): string {\n        const source = `';\\nvar eventId = (__lazyScope.elementRefArray.length);\\n__p+='data-co-element-ref=\"'+eventId+'\"';\nvar ${key} = null;\\n__lazyScope.elementRefArray[eventId] = function(target) {${key} = target;};\\n__p+='`; // Store a function to assign the element\n        return source;\n      },\n      lazyExec: function (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element): void {\n        // Iterate over stored functions and call them with the corresponding elements\n        lazyScope.elementRefArray.forEach(function (func: (target: Element) => void, eventId: number) {\n          // Find the element with the corresponding data-co-element-ref attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-element-ref=\"${eventId}\"]`\n          );\n          // Call the stored function with the element\n          if (!$elementTrigger) {\n            if (configs.debug) console.warn(`Element ref target not found for ID ${eventId} in template ${component.tmplId}`);\n            return;\n          }\n          delete ($elementTrigger as HTMLElement).dataset.coElementRef;\n          func.call($elementTrigger, $elementTrigger);\n        });\n      },\n    },\n    elementLoad: {\n      pattern: /data-co-load=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (elementLoad: string): string {\n        const elementLoadSplitArray = elementLoad.split(\"::\");\n        // Store the load function and custom data in lazy scope\n        const source = `';\\nconst eventId = (__lazyScope.elementLoadArray.length);\\n__p+='data-co-load=\"'+eventId+'\"';\n__lazyScope.elementLoadArray[eventId] = {loadFunc: ${elementLoadSplitArray[0]}, customData: ${elementLoadSplitArray[1]}};\\n__p+='`;\n        return source;\n      },\n      lazyExec: function (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element): void {\n        // Iterate over stored load functions and execute them with the corresponding elements\n        lazyScope.elementLoadArray.forEach(function (elementLoad: { loadFunc: Function; customData: Record<string, any> }, eventId: number) {\n          // Find the element with the corresponding data-co-load attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-load=\"${eventId}\"]`\n          );\n          if (!$elementTrigger) {\n            if (configs.debug) console.warn(`Element load target not found for ID ${eventId} in template ${component.tmplId}`);\n            return;\n          }\n          // Execute the load function with the element and context\n          delete ($elementTrigger as HTMLElement).dataset.coLoad;\n          try {\n            if (typeof elementLoad.loadFunc === 'function') {\n              const loadFuncParams: [Element, Element, { data: Record<string, any>; element: Element; customData: Record<string, any>; component: ComponentScope, compomint: CompomintGlobal }] = [\n                $elementTrigger,\n                $elementTrigger,\n                {\n                  \"data\": data,\n                  \"element\": $elementTrigger,\n                  \"customData\": elementLoad.customData,\n                  \"component\": component,\n                  \"compomint\": compomint,\n                },\n              ];\n              elementLoad.loadFunc.call(...loadFuncParams);\n            }\n          } catch (e: any) {\n            console.error(`Error executing elementLoad function for ID ${eventId} in template ${component.tmplId}:`, e, elementLoad.loadFunc);\n            if (configs.throwError) throw e;\n          }\n        });\n      },\n    },\n    event: {\n      pattern: /data-co-event=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (event: string): string {\n        const eventStrArray = event.split(\":::\");\n        // eventStrArray = [\"eventFunc::customData\", \"eventFunc::customData\"]\n        // Store event handlers in lazy scope\n        let source = `';\\n(() => {const eventId = (__lazyScope.eventArray.length);\\n__p+='data-co-event=\"'+eventId+'\"';\\n`;\n        const eventArray: string[] = [];\n        for (let i = 0, size = eventStrArray.length; i < size; i++) {\n          const eventSplitArray = eventStrArray[i].split(\"::\");\n          eventArray.push(\n            `{eventFunc: ${eventSplitArray[0]}, $parent: this, customData: ${eventSplitArray[1]}}`\n          );\n        }\n        source += `__lazyScope.eventArray[eventId] = [${eventArray.join(\",\")}];})()\\n__p+='`;\n        return source;\n      },\n      lazyExec: function (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element): void {\n        const self = this as TemplateRule; // Cast self to TemplateSettings\n        const attacher = self.attacher;\n        if (!attacher) return; // Guard against missing attacher\n\n        // Iterate over stored event handlers and attach them to elements\n        lazyScope.eventArray.forEach(function (selectedArray: { eventFunc: Function | Record<string, Function>; $parent: any; customData: any }[], eventId: number) {\n          // Find the element with the corresponding data-co-event attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-event=\"${eventId}\"]`\n          );\n          if (!$elementTrigger) {\n            if (configs.debug) console.warn(`Event target not found for ID ${eventId} in template ${component.tmplId}`); // Debugging: Log if target not found\n            return;\n          }\n          delete ($elementTrigger as HTMLElement).dataset.coEvent;\n          for (let i = 0, size = selectedArray.length; i < size; i++) {\n            const selected = selectedArray[i];\n            if (selected.eventFunc) {\n              if (Array.isArray(selected.eventFunc)) {\n                selected.eventFunc.forEach(function (func: Function) {\n                  attacher(\n                    self, data, lazyScope, component, wrapper, $elementTrigger,\n                    func,\n                    selected\n                  );\n                });\n              } else {\n                attacher(\n                  self, data, lazyScope, component, wrapper, $elementTrigger,\n                  selected.eventFunc,\n                  selected\n                );\n              }\n            }\n          }\n        });\n      },\n      trigger: function (target: Element, eventName: string): void {\n        const customEvent = new Event(eventName, {\n          // Dispatch a custom event on the target element\n          bubbles: true,\n          cancelable: true\n        });\n        target.dispatchEvent(customEvent);\n      },\n      attacher: function (\n        self: any, // Type properly if possible\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element,\n        $elementTrigger: Element,\n        eventFunc: Function | Record<string, Function>,\n        eventData: Record<string, any>\n      ): void {\n        const trigger = self.trigger;\n        const $childTarget = firstElementChild(wrapper);\n        const $targetElement = childElementCount(wrapper) === 1 ? $childTarget : null;\n\n        // Attach event listeners based on the type of eventFunc\n\n        if (!eventFunc) {\n          return;\n        }\n\n        const eventFuncParams: [Element, Event | Element | null, { data: Record<string, any>; customData: any; element: Element; componentElement: Element | null | undefined; component: ComponentScope, compomint: CompomintGlobal }] = [\n          $elementTrigger,\n          null,\n          {\n            \"data\": data,\n            \"customData\": eventData.customData,\n            \"element\": $elementTrigger,\n            \"componentElement\": $targetElement || $childTarget?.parentElement,\n            \"component\": component,\n            \"compomint\": compomint,\n          },\n        ];\n\n        // Basic case: eventFunc is a single function\n        if (typeof eventFunc === 'function') {\n          const eventListener = function (event: Event) {\n            event.stopPropagation();\n            eventFuncParams[1] = event;\n            try {\n              eventFunc.call(...eventFuncParams);\n            } catch (e: any) {\n              console.error(`Error in event handler for template ${component.tmplId}:`, e, eventFunc);\n              if (configs.throwError) throw e;\n            }\n          };\n          // Attach a click event listener for a single function\n          $elementTrigger.addEventListener(\"click\", eventListener);\n          eventData.element = $elementTrigger; // For remove eventListener\n          eventData.eventFunc = eventListener; // For remove eventListener\n\n          return;\n        }\n\n        if (!isPlainObject(eventFunc)) {\n          return;\n        }\n\n        // Advanced case: eventFunc is an object mapping event types to handlers\n        const eventMap = eventFunc as Record<string, Function>;\n        // Handle event map with multiple event types\n        const triggerName = eventMap.triggerName as unknown as string | undefined; // Optional key to store trigger functions\n        if (triggerName) {\n          component.trigger = component.trigger || {};\n          component.trigger[triggerName] = {};\n        }\n\n        Object.keys(eventMap).forEach(function (eventType: string) {\n          const selectedEventFunc = eventMap[eventType];\n\n          // Handle special event types like \"load\", \"namedElement\", and \"triggerName\"\n          if (eventType === \"load\") {\n            eventFuncParams[1] = $elementTrigger;\n            try {\n              selectedEventFunc.call(...eventFuncParams);\n            } catch (e: any) {\n              console.error(`Error in 'load' event handler for template ${component.tmplId}:`, e, selectedEventFunc);\n              if (configs.throwError) throw e;\n            }\n            return;\n          } else if (eventType === \"namedElement\") {\n            component[selectedEventFunc as unknown as string] = $elementTrigger;\n            return;\n          } else if (eventType === \"triggerName\") {\n            return;\n            // Attach event listeners for other event types\n          }\n\n\n          const eventListener = function (event: Event) {\n            event.stopPropagation();\n            eventFuncParams[1] = event;\n            try {\n              selectedEventFunc.call(...eventFuncParams);\n            } catch (e: any) {\n              console.error(`Error in '${eventType}' event handler for template ${component.tmplId}:`, e, selectedEventFunc);\n              if (configs.throwError) throw e;\n            }\n          };\n\n          $elementTrigger.addEventListener(eventType, eventListener);\n          eventData.element = $elementTrigger; // For remove eventListener\n          eventFunc[eventType] = eventListener; // For remove eventListener\n\n          if (triggerName && trigger) {\n            component.trigger![triggerName][eventType] = function () {\n              trigger($elementTrigger, eventType);\n            };\n          }\n        });\n      },\n    },\n    element: {\n      pattern: /##%([\\s\\S]+?)##/g,\n      exec: function (target: string): string {\n        // Store element insertion information in lazy scope\n        const elementSplitArray = target.split(\"::\");\n        const source = `';\\n(() => {\nconst elementId = (__lazyScope.elementArray.length);\n__p+='<template data-co-tmpl-element-id=\"'+elementId+'\"></template>';\n__lazyScope.elementArray[elementId] = {childTarget: ${elementSplitArray[0]}, nonblocking: ${(elementSplitArray[1] || false)}};})();\n__p+='`;\n        return source;\n      },\n      lazyExec: function (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element): void {\n        const self = this as TemplateRule; // Cast self\n\n        lazyScope.elementArray.forEach(function (ele: { childTarget: any; nonblocking: boolean | number }, elementId: number) {\n          // Retrieve element insertion details from lazy scope\n          const childTarget = ele.childTarget;\n          const nonblocking = ele.nonblocking;\n          // Find the placeholder element\n          const $tmplElement = wrapper.querySelector<TemplateElement>(\n            `template[data-co-tmpl-element-id=\"${elementId}\"]`\n          );\n          // Perform the element insertion\n          if (!$tmplElement) {\n            if (configs.debug) console.warn(`Element insertion placeholder not found for ID ${elementId} in template ${component.tmplId}`);\n            return;\n          }\n          if (!$tmplElement.parentNode) {\n            if (configs.debug) console.warn(`Element insertion placeholder for ID ${elementId} in template ${component.tmplId} has no parent.`);\n            return;\n          }\n\n          const doFunc = function () {\n            if (!$tmplElement || !$tmplElement.parentNode) {\n              if (configs.debug) console.warn(`Placeholder for ID ${elementId} removed before insertion in template ${component.tmplId}.`);\n              return;\n            }\n\n            // Handle different types of childTarget for insertion\n            try {\n              if (childTarget instanceof Array) {\n                const docFragment = document.createDocumentFragment();\n                childTarget.forEach(function (child: any) {\n                  if (!child) return;\n                  const childElement = child.element || child;\n                  let nodeToAppend: Node | null = null;\n                  // Convert child to a DOM node if necessary\n\n                  if (typeof childElement === \"string\" || typeof childElement === \"number\") {\n                    nodeToAppend = stringToElement(childElement);\n                  } else if (typeof childElement === \"function\") {\n                    nodeToAppend = stringToElement(childElement());\n                  } else if (childElement instanceof Node) {\n                    nodeToAppend = childElement;\n                  } else {\n                    if (configs.debug) console.warn(`Invalid item type in element array for ID ${elementId}, template ${component.tmplId}:`, childElement);\n                    return;\n                  }\n                  // Append the node to the document fragment\n                  if (child.beforeAppendTo) { try { child.beforeAppendTo(); } catch (e) { console.error(\"Error in beforeAppendTo (array item):\", e); } }\n                  if (nodeToAppend) docFragment.appendChild(nodeToAppend);\n                });\n                // Replace the placeholder with the document fragment\n                $tmplElement.parentNode.replaceChild(docFragment, $tmplElement);\n\n                // Call afterAppendTo for each child\n                childTarget.forEach(function (child: any) {\n                  if (child && child.afterAppendTo) {\n                    setTimeout(() => {\n                      try { child.afterAppendTo(); } catch (e) { console.error(\"Error in afterAppendTo (array item):\", e); }\n                    }, 0);\n                  }\n                });\n                // Handle string, number, or function types\n              } else if (typeof childTarget === \"string\" || typeof childTarget === \"number\") {\n                $tmplElement.parentNode.replaceChild(\n                  stringToElement(childTarget),\n                  $tmplElement\n                );\n                // Handle function type\n              } else if (typeof childTarget === \"function\") {\n                $tmplElement.parentNode.replaceChild(\n                  stringToElement(childTarget()),\n                  $tmplElement\n                );\n                // Handle Node or ComponentScope types\n              } else if (childTarget && (childTarget.element || childTarget) instanceof Node) {\n                const childScope = childTarget as ComponentScope; // Assume it might be a scope\n                const childElement = childScope.element || childScope;\n\n                // Replace the placeholder with the child element\n                if (childScope.beforeAppendTo) { try { childScope.beforeAppendTo(); } catch (e) { console.error(\"Error in beforeAppendTo:\", e); } }\n                $tmplElement.parentNode.replaceChild(childElement, $tmplElement);\n                // Call afterAppendTo if available\n                if (childScope.afterAppendTo) {\n                  setTimeout(() => {\n                    try {\n                      if (childScope.afterAppendTo) childScope.afterAppendTo();\n                    } catch (e) { console.error(\"Error in afterAppendTo:\", e); }\n                  }, 0);\n                }\n                // Set parentComponent if it's a component\n                if (childScope.tmplId) {\n                  childScope.parentComponent = component;\n                }\n                // Handle invalid target types\n              } else {\n                if (configs.debug) console.warn(`Invalid target for element insertion ID ${elementId}, template ${component.tmplId}:`, childTarget);\n                $tmplElement.parentNode.removeChild($tmplElement);\n              }\n            } catch (e: any) {\n              console.error(`Error during element insertion for ID ${elementId}, template ${component.tmplId}:`, e);\n              if (configs.throwError) throw e;\n              if ($tmplElement && $tmplElement.parentNode) {\n                try { $tmplElement.parentNode.removeChild($tmplElement); } catch (removeError) { /* Ignore */ }\n              }\n            } // end try\n          }; // end doFunc\n\n          (nonblocking === undefined || nonblocking === false)\n            // Execute immediately or with a delay based on nonblocking\n            ? doFunc()\n            : setTimeout(doFunc, typeof nonblocking === 'number' ? nonblocking : 0);\n\n        }); // end forEach\n      }\n    },\n    lazyEvaluate: {\n      pattern: /###([\\s\\S]+?)##/g,\n      exec: function (lazyEvaluate: string): string {\n        const source = `';\\n__lazyScope.lazyEvaluateArray.push(function(data) {${lazyEvaluate}});\\n__p+='`;\n        // Store the lazy evaluation function in lazy scope\n        return source;\n      },\n      lazyExec: function (data: Record<string, any>, lazyScope: LazyScope, component: ComponentScope, wrapper: DocumentFragment | Element): void {\n        // Execute stored lazy evaluation functions\n        const $childTarget = firstElementChild(wrapper);\n        const $targetElement =\n          childElementCount(wrapper) === 1 ? $childTarget : null;\n        lazyScope.lazyEvaluateArray.forEach(function (selectedFunc: (data: Record<string, any>) => void, idx: number) {\n          // Call the function with the appropriate context\n          try {\n            selectedFunc.call($targetElement || wrapper, data); // Use wrapper if multiple elements\n          } catch (e: any) {\n            console.error(`Error in lazyEvaluate block ${idx} for template ${component.tmplId}:`, e, selectedFunc);\n            if (configs.throwError) throw e;\n          }\n        });\n        return;\n      },\n    },\n    evaluate: {\n      pattern: /##([\\s\\S]+?)##/g,\n      exec: (evaluate: string): string => {\n        // Insert arbitrary JavaScript code into the template function\n        return \"';\\n\" + evaluate + \"\\n__p+='\";\n      },\n    },\n  },\n  keys: {\n    dataKeyName: \"data\",\n    statusKeyName: \"status\",\n    componentKeyName: \"component\",\n    i18nKeyName: \"i18n\",\n  }\n\n});\n\nexport { defaultTemplateConfig }","\nimport { CompomintGlobal } from \"./type\"\n\nconst applyBuiltInTemplates = (addTmpl: CompomintGlobal[\"addTmpl\"]): void => {\n  // co-Ele is a shorthand for co-Element, it will generate a div element with the given props and event\n  addTmpl(\"co-Ele\", `##%compomint.tools.genElement(data[0], data[1])##`);\n  addTmpl(\n    \"co-Element\",\n    `##\n  data.tag = data.tag || 'div';\n  ##\n  &lt;##=data.tag##\n    ##=data.id ? 'id=\"' + (data.id === true ? component._id : data.id) + '\"' : ''##\n    data-co-props=\"##:data.props##\"\n    data-co-event=\"##:data.event##\"&gt;\n    ##if (typeof data.content === \"string\") {##\n    ##=data.content##\n    ##} else {##\n      ##%data.content##\n    ##}##\n  &lt;/##=data.tag##&gt;`\n  );\n}\n\nexport { applyBuiltInTemplates }"],"names":["firstElementChild","ele","children","childNodes","i","size","length","Element","childElementCount","Array","prototype","filter","call","child","cleanNode","node","n","nodeType","test","nodeValue","removeChild","domParser","DOMParser","stringToElement","str","isNaN","Number","document","createTextNode","String","body","parseFromString","firstChild","fragment","createDocumentFragment","appendChild","e","Object","assign","defineProperty","value","target","params","TypeError","to","index","nextSource","nextKey","hasOwnProperty","writable","configurable","CharacterData","DocumentType","forEach","item","enumerable","this","parentNode","window","Node","get","contains","compomint","tmpl","tools","configs","printExecTime","debug","throwError","cachedTmpl","tmplCache","Map","has","set","elements","Set","isSupportTemplateTag","createElement","noMatch","escapes","escaper","templateConfig","rules","style","pattern","exec","dumy","innerHTML","styleNode","content","querySelector","id","oldStyleNode","getElementById","head","commentArea","preEvaluate","tmplId","Function","console","error","name","message","warn","interpolate","escape","elementProps","props","lazyExec","data","lazyScope","component","wrapper","elementPropsArray","eventId","$elementTrigger","dataset","coProps","keys","key","setAttribute","namedElement","namedElementArray","coNamedElement","elementRef","elementRefArray","func","coElementRef","elementLoad","elementLoadSplitArray","split","elementLoadArray","coLoad","loadFunc","loadFuncParams","element","customData","event","eventStrArray","source","eventArray","eventSplitArray","push","join","self","attacher","selectedArray","coEvent","selected","eventFunc","isArray","trigger","eventName","customEvent","Event","bubbles","cancelable","dispatchEvent","eventData","$childTarget","$targetElement","eventFuncParams","componentElement","parentElement","eventListener","stopPropagation","addEventListener","toString","eventMap","triggerName","eventType","selectedEventFunc","elementSplitArray","elementArray","elementId","childTarget","nonblocking","$tmplElement","doFunc","docFragment","childElement","nodeToAppend","beforeAppendTo","replaceChild","afterAppendTo","setTimeout","childScope","parentComponent","removeError","undefined","lazyEvaluate","lazyEvaluateArray","selectedFunc","idx","evaluate","dataKeyName","statusKeyName","componentKeyName","i18nKeyName","defaultTemplateConfig","escapeHtml","escapeMap","unescapeMap","fromEntries","entries","map","createEscaper","match","replace","testRegexp","RegExp","replaceRegexp","string","unescape","matcherFunc","templateRules","patternArray","execArray","lazyExecMap","lazyScopeSeed","templateRule","arrayKey","lazyExecKeys","JSON","stringify","escapeFunc","defaultMatcher","templateBuilder","template","templateText","customTemplateConfig","matcher","text","time","offset","selectedMatchContent","slice","matchIndex","some","timeEnd","templateParser","sourceGenFunc","renderingFunc","wrapperElement","callback","baseComponent","firstArg","$wrapperElement","$callback","$baseComponent","parse","status","newComponent","remove","spacer","beforeRemove","selectedEvent","removeEventListener","parent","removedElement","afterRemove","appendTo","release","render","newData","refresh","reflashData","reflash","_id","genId","hasParent","temp","returnTarget","renderedHTML","i18n","log","createComment","tagName","from","host","shadow","attachShadow","mode","$props","prop","startsWith","camelCased","substring","g","toUpperCase","normalize","liveReloadSupport","getOwnPropertyNames","keepProps","includes","currentComponent","targetElement","tmplFunc","hooks","beforeRefresh","afterRefresh","currentData","tmplMeta","tmplIdNames","group","groupObj","part","charAt","remapTmpl","json","oldKey","newKey","meta","safeTemplate","encodedSource","addTmpl","addTmpls","removeInnerTemplate","container","querySelectorAll","coLoadScript","addTmplByUrl","importData","option","defaultOptions","loadScript","loadStyle","loadLink","mergedOptions","appendElements","oldElement","loadResource","dataItem","Promise","resolve","reject","parsedData","obj","url","src","currentOption","endsWith","script","genElement","async","onerror","link","type","rel","href","requestFunc","templateContainer","tmplSettings","links","styles","scripts","executableScripts","nodeName","scriptElm","getAttributeNames","getAttribute","textContent","importFunc","finalCallback","all","then","catch","err","xmlhttp","XMLHttpRequest","onreadystatechange","readyState","DONE","responseText","statusText","ontimeout","method","open","timeout","headers","setRequestHeader","send","addI18n","fullKey","i18nObj","langKeyNames","keyLength","defaultText","lang","documentElement","label","subKey","addI18ns","i18nObjs","elementCount","attrs","actualAttrs","unshift","concat","propName","toLowerCase","propsObjects","mergedProps","propStrArray","escapedValue","applyBuiltInTemplates"],"mappings":"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"}