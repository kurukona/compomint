{"version":3,"file":"compomint.esm.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/default-template-engine.ts","../src/ssr.ts","../src/ssr-renderer.ts","../src/compomint.ts","../src/default-template-engine-ssr.ts","../src/built-in-templates.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","\nconst firstElementChild = function (ele: Element | DocumentFragment): Element | null {\n  if (ele.firstElementChild) return ele.firstElementChild;\n  const children = ele.childNodes;\n  for (let i = 0, size = children.length; i < size; i++) {\n    if (children[i] instanceof Element) {\n      return children[i] as Element;\n    }\n  }\n  return null;\n};\n\nconst childNodeCount = function (ele: Element | DocumentFragment): number {\n  return (\n    ele.childElementCount ||\n    Array.prototype.filter.call(ele.childNodes || [], function (child: Node) {\n      return child instanceof Node;\n    }).length\n  );\n};\n\nconst childElementCount = function (ele: Element | DocumentFragment): number {\n  return (\n    ele.childElementCount ||\n    Array.prototype.filter.call(ele.childNodes || [], function (child: Node) {\n      return child instanceof Element;\n    }).length\n  );\n};\n\nconst cleanNode = function (node: Node): void {\n  if (!node.childNodes) return;\n  for (let n = 0; n < node.childNodes.length; n++) {\n    const child = node.childNodes[n];\n    if (\n      child.nodeType === 8 || // Comment node\n      (child.nodeType === 3 && !/\\S/.test(child.nodeValue || '')) // Text node with only whitespace\n    ) {\n      node.removeChild(child);\n      n--; // Adjust index after removal\n    } else if (child.nodeType === 1) {\n      // Element node\n      cleanNode(child); // Recurse\n    }\n  }\n};\n\nconst getDOMParser = () => {\n  if (typeof DOMParser !== 'undefined') {\n    return new DOMParser();\n  }\n  // SSR fallback - create mock DOMParser\n  return {\n    parseFromString: (str: string, type: string) => {\n      const mockDoc = {\n        body: {\n          childNodes: [],\n          firstChild: null,\n          appendChild: () => {},\n          removeChild: () => {}\n        }\n      };\n      return mockDoc;\n    }\n  };\n};\n\nconst stringToElement = function (str: string | number): Node {\n  if (typeof str === 'number' || !isNaN(Number(str))) {\n    return document.createTextNode(String(str));\n  } else if (typeof str === 'string') {\n    try {\n      const domParser = getDOMParser();\n      const doc = domParser.parseFromString(str, \"text/html\");\n      const body = doc.body;\n      if (body.childNodes.length === 1) {\n        return body.firstChild!;\n      } else {\n        const fragment = document.createDocumentFragment();\n        while (body.firstChild) {\n          fragment.appendChild(body.firstChild);\n        }\n        return fragment;\n      }\n    } catch (e) {\n      return document.createTextNode(str);\n    }\n  } else {\n    return document.createTextNode('');\n  }\n};\n\nconst isPlainObject = function (value: unknown) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport {\n  firstElementChild,\n  childNodeCount,\n  childElementCount,\n  cleanNode,\n  stringToElement,\n  isPlainObject,\n};\n","import {\n  ComponentScope,\n  LazyScope,\n  TemplateEngine,\n  TemplateRule,\n  TemplateElement,\n  CompomintConfigs,\n  CompomintGlobal,\n} from \"./type\";\n\nimport {\n  firstElementChild,\n  childElementCount,\n  stringToElement,\n  isPlainObject,\n} from \"./utils\";\n\n//\n// Default template settings\n//\nconst defaultTemplateEngine = (compomint: CompomintGlobal): TemplateEngine => {\n  const configs: CompomintConfigs = compomint.configs;\n  return {\n    rules: {\n      style: {\n        pattern: /(\\<style id=[\\s\\S]+?\\>[\\s\\S]+?\\<\\/style\\>)/g,\n        exec: function (style): string {\n          // Create a temporary element to parse the style tag\n          const dumy = document.createElement(\"template\");\n          dumy.innerHTML = style;\n          const styleNode = (dumy.content || dumy).querySelector(\"style\");\n          if (!styleNode || !styleNode.id) return \"\"; // Skip if no style node or ID\n          const oldStyleNode = document.getElementById(styleNode.id);\n          if (oldStyleNode) oldStyleNode.parentNode?.removeChild(oldStyleNode);\n          document.head.appendChild(styleNode);\n          return \"\";\n        },\n      },\n      commentArea: {\n        pattern: /##\\*([\\s\\S]+?)##/g,\n        exec: function (commentArea: string): string {\n          // Return an empty string to remove the comment block\n          return ``;\n        },\n      },\n      preEvaluate: {\n        pattern: /##!([\\s\\S]+?)##/g,\n        exec: function (preEvaluate: string, tmplId: string): string {\n          try {\n            // Execute the code in a new function context\n            new Function(\"compomint\", \"tmplId\", preEvaluate)(compomint, tmplId);\n          } catch (e: any) {\n            if (configs.throwError) {\n              console.error(\n                `Template preEvaluate error in \"${tmplId}\", ${e.name}: ${e.message}`\n              );\n              throw e;\n            } else {\n              console.warn(\n                `Template preEvaluate error in \"${tmplId}\", ${e.name}: ${e.message}`\n              );\n            }\n          }\n          return ``;\n        },\n      },\n      interpolate: {\n        pattern: /##=([\\s\\S]+?)##/g,\n        exec: function (interpolate: string): string {\n          // Construct JavaScript code to interpolate the value\n          const interpolateSyntax = `typeof (interpolate)=='function' ? (interpolate)() : (interpolate)`;\n          return `';\\n{let __t, interpolate=${interpolate};\\n__p+=((__t=(${interpolateSyntax}))==null ? '' : String(__t) );};\\n__p+='`; // Ensure string conversion\n        },\n      },\n      escape: {\n        pattern: /##-([\\s\\S]+?)##/g,\n        exec: function (escape: string): string {\n          const escapeSyntax = `compomint.tools.escapeHtml.escape(typeof (escape)=='function' ? (escape)() : (escape))`;\n          // Construct JavaScript code to escape HTML characters in the value\n          return `';\\n{let __t, escape=${escape};\\n__p+=((__t=(${escapeSyntax}))==null ? '' : String(__t) );};\\n__p+='`; // Ensure string conversion before escape\n        },\n      },\n      elementProps: {\n        pattern: /data-co-props=\"##:([\\s\\S]+?)##\"/g,\n        exec: function (props: string): string {\n          const source = `';\\n{const eventId = (__lazyScope.elementPropsArray.length);\\n__p+='data-co-props=\"'+eventId+'\"';\\n\n__lazyScope.elementPropsArray[eventId] = ${props}};\\n__p+='`; // Store props in lazy scope\n          return source;\n        },\n        lazyExec: function (\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element\n        ): void {\n          // Iterate over stored props and apply them to elements\n          lazyScope.elementPropsArray.forEach(function (\n            props: Record<string, any> | null,\n            eventId: number\n          ) {\n            if (!props) return;\n            // Find the element with the corresponding data-co-props attribute\n            const $elementTrigger = wrapper.querySelector<Element>(\n              `[data-co-props=\"${eventId}\"]`\n            );\n            // Remove the temporary attribute and set the properties\n            if (!$elementTrigger) return;\n            delete ($elementTrigger as HTMLElement).dataset.coProps;\n            Object.keys(props).forEach(function (key: string) {\n              $elementTrigger.setAttribute(key, String(props[key])); // Ensure value is string\n            });\n          });\n        },\n      },\n      namedElement: {\n        pattern: /data-co-named-element=\"##:([\\s\\S]+?)##\"/g,\n        exec: function (key: string): string {\n          const source = `';\\nconst eventId = (__lazyScope.namedElementArray.length);\\n__p+='data-co-named-element=\"'+eventId+'\"';\\n\n__lazyScope.namedElementArray[eventId] = ${key};\\n__p+='`; // Store the key in lazy scope\n          return source;\n        },\n        lazyExec: function (\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element\n        ): void {\n          // Iterate over stored keys and assign elements to the component\n          lazyScope.namedElementArray.forEach(function (\n            key: string,\n            eventId: number\n          ) {\n            // Find the element with the corresponding data-co-named-element attribute\n            const $elementTrigger = wrapper.querySelector<Element>(\n              `[data-co-named-element=\"${eventId}\"]`\n            );\n            // Assign the element to the component using the key\n            if (!$elementTrigger) {\n              if (configs.debug)\n                console.warn(\n                  `Named element target not found for ID ${eventId} in template ${component.tmplId}`\n                );\n              return;\n            }\n            delete ($elementTrigger as HTMLElement).dataset.coNamedElement;\n            component[key] = $elementTrigger;\n          });\n        },\n      },\n      elementRef: {\n        pattern: /data-co-element-ref=\"##:([\\s\\S]+?)##\"/g,\n        exec: function (key: string): string {\n          const source = `';\\n{const eventId = (__lazyScope.elementRefArray.length);\\n__p+='data-co-element-ref=\"'+eventId+'\"';\nvar ${key} = null;\\n__lazyScope.elementRefArray[eventId] = function(target) {${key} = target;}};\\n__p+='`; // Store a function to assign the element\n          return source;\n        },\n        lazyExec: function (\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element\n        ): void {\n          // Iterate over stored functions and call them with the corresponding elements\n          lazyScope.elementRefArray.forEach(function (\n            func: (target: Element) => void,\n            eventId: number\n          ) {\n            // Find the element with the corresponding data-co-element-ref attribute\n            const $elementTrigger = wrapper.querySelector<Element>(\n              `[data-co-element-ref=\"${eventId}\"]`\n            );\n            // Call the stored function with the element\n            if (!$elementTrigger) {\n              if (configs.debug)\n                console.warn(\n                  `Element ref target not found for ID ${eventId} in template ${component.tmplId}`\n                );\n              return;\n            }\n            delete ($elementTrigger as HTMLElement).dataset.coElementRef;\n            func.call($elementTrigger, $elementTrigger);\n          });\n        },\n      },\n      elementLoad: {\n        pattern: /data-co-load=\"##:([\\s\\S]+?)##\"/g,\n        exec: function (elementLoad: string): string {\n          const elementLoadSplitArray = elementLoad.split(\"::\");\n          // Store the load function and custom data in lazy scope\n          const source = `';\\n{const eventId = (__lazyScope.elementLoadArray.length);\\n__p+='data-co-load=\"'+eventId+'\"';\n__lazyScope.elementLoadArray[eventId] = {loadFunc: ${elementLoadSplitArray[0]}, customData: ${elementLoadSplitArray[1]}};}\\n__p+='`; // 'customData' is determined when compiled, so it does not change even if refreshed.\n          return source;\n        },\n        lazyExec: function (\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element\n        ): void {\n          // Iterate over stored load functions and execute them with the corresponding elements\n          lazyScope.elementLoadArray.forEach(function (\n            elementLoad: {\n              loadFunc: Function;\n              customData: Record<string, any>;\n            },\n            eventId: number\n          ) {\n            // Find the element with the corresponding data-co-load attribute\n            const $elementTrigger = wrapper.querySelector<Element>(\n              `[data-co-load=\"${eventId}\"]`\n            );\n            if (!$elementTrigger) {\n              if (configs.debug)\n                console.warn(\n                  `Element load target not found for ID ${eventId} in template ${component.tmplId}`\n                );\n              return;\n            }\n            // Execute the load function with the element and context\n            delete ($elementTrigger as HTMLElement).dataset.coLoad;\n            try {\n              if (typeof elementLoad.loadFunc === \"function\") {\n                const loadFuncParams: [\n                  Element,\n                  Element,\n                  {\n                    data: Record<string, any>;\n                    element: Element;\n                    customData: Record<string, any>;\n                    component: ComponentScope;\n                    compomint: CompomintGlobal;\n                  }\n                ] = [\n                  $elementTrigger,\n                  $elementTrigger,\n                  {\n                    data: data,\n                    element: $elementTrigger,\n                    customData: elementLoad.customData,\n                    component: component,\n                    compomint: compomint,\n                  },\n                ];\n                elementLoad.loadFunc.call(...loadFuncParams);\n              }\n            } catch (e: any) {\n              console.error(\n                `Error executing elementLoad function for ID ${eventId} in template ${component.tmplId}:`,\n                e,\n                elementLoad.loadFunc\n              );\n              if (configs.throwError) throw e;\n            }\n          });\n        },\n      },\n      event: {\n        pattern: /data-co-event=\"##:([\\s\\S]+?)##\"/g,\n        exec: function (event: string): string {\n          const eventStrArray = event.split(\":::\");\n          // eventStrArray = [\"eventFunc::customData\", \"eventFunc::customData\"]\n          // Store event handlers in lazy scope\n          let source = `';\\n{const eventId = (__lazyScope.eventArray.length);\\n__p+='data-co-event=\"'+eventId+'\"';\\n`;\n          const eventArray: string[] = [];\n          for (let i = 0, size = eventStrArray.length; i < size; i++) {\n            const eventSplitArray = eventStrArray[i].split(\"::\");\n            eventArray.push(\n              `{eventFunc: ${eventSplitArray[0]}, $parent: this, customData: ${eventSplitArray[1]}}`\n            );\n          }\n          source += `__lazyScope.eventArray[eventId] = [${eventArray.join(\n            \",\"\n          )}];}\\n__p+='`;\n          return source;\n        },\n        lazyExec: function (\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element\n        ): void {\n          const self = this as TemplateRule; // Cast self to TemplateSettings\n          const attacher = self.attacher;\n          if (!attacher) return; // Guard against missing attacher\n\n          // Iterate over stored event handlers and attach them to elements\n          lazyScope.eventArray.forEach(function (\n            selectedArray: {\n              eventFunc: Function | Record<string, Function>;\n              $parent: any;\n              customData: any;\n            }[],\n            eventId: number\n          ) {\n            // Find the element with the corresponding data-co-event attribute\n            const $elementTrigger = wrapper.querySelector<Element>(\n              `[data-co-event=\"${eventId}\"]`\n            );\n            if (!$elementTrigger) {\n              if (configs.debug)\n                console.warn(\n                  `Event target not found for ID ${eventId} in template ${component.tmplId}`\n                ); // Debugging: Log if target not found\n              return;\n            }\n            delete ($elementTrigger as HTMLElement).dataset.coEvent;\n            for (let i = 0, size = selectedArray.length; i < size; i++) {\n              const selected = selectedArray[i];\n              if (selected.eventFunc) {\n                if (Array.isArray(selected.eventFunc)) {\n                  selected.eventFunc.forEach(function (func: Function) {\n                    attacher(\n                      self,\n                      data,\n                      lazyScope,\n                      component,\n                      wrapper,\n                      $elementTrigger,\n                      func,\n                      selected\n                    );\n                  });\n                } else {\n                  attacher(\n                    self,\n                    data,\n                    lazyScope,\n                    component,\n                    wrapper,\n                    $elementTrigger,\n                    selected.eventFunc,\n                    selected\n                  );\n                }\n              }\n            }\n          });\n        },\n        trigger: function (target: Element, eventName: string): void {\n          const customEvent = new Event(eventName, {\n            // Dispatch a custom event on the target element\n            bubbles: true,\n            cancelable: true,\n          });\n          target.dispatchEvent(customEvent);\n        },\n        attacher: function (\n          self: any, // Type properly if possible\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element,\n          $elementTrigger: Element,\n          eventFunc: Function | Record<string, Function>,\n          eventData: Record<string, any>\n        ): void {\n          const trigger = self.trigger;\n          const $childTarget = firstElementChild(wrapper);\n          const $targetElement =\n            childElementCount(wrapper) === 1 ? $childTarget : null;\n\n          // Attach event listeners based on the type of eventFunc\n\n          if (!eventFunc) {\n            return;\n          }\n\n          const eventFuncParams: [\n            Element,\n            Event | Element | null,\n            {\n              data: Record<string, any>;\n              customData: any;\n              element: Element;\n              componentElement: Element | null | undefined;\n              component: ComponentScope;\n              compomint: CompomintGlobal;\n            }\n          ] = [\n            $elementTrigger,\n            null,\n            {\n              data: data,\n              customData: eventData.customData,\n              element: $elementTrigger,\n              componentElement: $targetElement || $childTarget?.parentElement,\n              component: component,\n              compomint: compomint,\n            },\n          ];\n\n          // Basic case: eventFunc is a single function\n          if (typeof eventFunc === \"function\") {\n            const eventListener = function (event: Event) {\n              event.stopPropagation();\n              eventFuncParams[1] = event;\n              try {\n                eventFunc.call(...eventFuncParams);\n              } catch (e: any) {\n                console.error(\n                  `Error in event handler for template ${component.tmplId}:`,\n                  e,\n                  eventFunc\n                );\n                if (configs.throwError) throw e;\n              }\n            };\n            // Attach a click event listener for a single function\n            $elementTrigger.addEventListener(\"click\", eventListener);\n            eventData.element = $elementTrigger; // For remove eventListener\n            eventData.eventFunc = eventListener; // For remove eventListener\n\n            return;\n          }\n\n          if (!isPlainObject(eventFunc)) {\n            return;\n          }\n\n          // Advanced case: eventFunc is an object mapping event types to handlers\n          const eventMap = eventFunc as Record<string, Function>;\n          // Handle event map with multiple event types\n          const triggerName = eventMap.triggerName as unknown as\n            | string\n            | undefined; // Optional key to store trigger functions\n          if (triggerName) {\n            component.trigger = component.trigger || {};\n            component.trigger[triggerName] = {};\n          }\n\n          Object.keys(eventMap).forEach(function (eventType: string) {\n            const selectedEventFunc = eventMap[eventType];\n\n            // Handle special event types like \"load\", \"namedElement\", and \"triggerName\"\n            if (eventType === \"load\") {\n              eventFuncParams[1] = $elementTrigger;\n              try {\n                selectedEventFunc.call(...eventFuncParams);\n              } catch (e: any) {\n                console.error(\n                  `Error in 'load' event handler for template ${component.tmplId}:`,\n                  e,\n                  selectedEventFunc\n                );\n                if (configs.throwError) throw e;\n              }\n              return;\n            } else if (eventType === \"namedElement\") {\n              component[selectedEventFunc as unknown as string] =\n                $elementTrigger;\n              return;\n            } else if (eventType === \"triggerName\") {\n              return;\n              // Attach event listeners for other event types\n            }\n\n            const eventListener = function (event: Event) {\n              event.stopPropagation();\n              eventFuncParams[1] = event;\n              try {\n                selectedEventFunc.call(...eventFuncParams);\n              } catch (e: any) {\n                console.error(\n                  `Error in '${eventType}' event handler for template ${component.tmplId}:`,\n                  e,\n                  selectedEventFunc\n                );\n                if (configs.throwError) throw e;\n              }\n            };\n\n            $elementTrigger.addEventListener(eventType, eventListener);\n            eventData.element = $elementTrigger; // For remove eventListener\n            eventFunc[eventType] = eventListener; // For remove eventListener\n\n            if (triggerName && trigger) {\n              component.trigger![triggerName][eventType] = function () {\n                trigger($elementTrigger, eventType);\n              };\n            }\n          });\n        },\n      },\n      element: {\n        pattern: /##%([\\s\\S]+?)##/g,\n        exec: function (target: string): string {\n          // Store element insertion information in lazy scope\n          const elementSplitArray = target.split(\"::\");\n          const source = `';\\n{\nconst elementId = (__lazyScope.elementArray.length);\n__p+='<template data-co-tmpl-element-id=\"'+elementId+'\"></template>';\n__lazyScope.elementArray[elementId] = {childTarget: ${\n            elementSplitArray[0]\n          }, nonblocking: ${elementSplitArray[1] || false}};};\n__p+='`;\n          return source;\n        },\n        lazyExec: function (\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element\n        ): void {\n          const self = this as TemplateRule; // Cast self\n\n          lazyScope.elementArray.forEach(function (\n            ele: { childTarget: any; nonblocking: boolean | number },\n            elementId: number\n          ) {\n            // Retrieve element insertion details from lazy scope\n            const childTarget = ele.childTarget;\n            const nonblocking = ele.nonblocking;\n            // Find the placeholder element\n            const $tmplElement = wrapper.querySelector<TemplateElement>(\n              `template[data-co-tmpl-element-id=\"${elementId}\"]`\n            );\n            // Perform the element insertion\n            if (!$tmplElement) {\n              if (configs.debug)\n                console.warn(\n                  `Element insertion placeholder not found for ID ${elementId} in template ${component.tmplId}`\n                );\n              return;\n            }\n            if (!$tmplElement.parentNode) {\n              if (configs.debug)\n                console.warn(\n                  `Element insertion placeholder for ID ${elementId} in template ${component.tmplId} has no parent.`\n                );\n              return;\n            }\n\n            const doFunc = function () {\n              if (!$tmplElement || !$tmplElement.parentNode) {\n                if (configs.debug)\n                  console.warn(\n                    `Placeholder for ID ${elementId} removed before insertion in template ${component.tmplId}.`\n                  );\n                return;\n              }\n\n              // Handle different types of childTarget for insertion\n              try {\n                if (childTarget instanceof Array) {\n                  const docFragment = document.createDocumentFragment();\n                  childTarget.forEach(function (child: any) {\n                    if (!child) return;\n                    const childElement = child.element || child;\n                    let nodeToAppend: Node | null = null;\n                    // Convert child to a DOM node if necessary\n\n                    if (\n                      typeof childElement === \"string\" ||\n                      typeof childElement === \"number\"\n                    ) {\n                      nodeToAppend = stringToElement(childElement);\n                    } else if (typeof childElement === \"function\") {\n                      nodeToAppend = stringToElement(childElement());\n                    } else if (childElement instanceof Node) {\n                      nodeToAppend = childElement;\n                    } else {\n                      if (configs.debug)\n                        console.warn(\n                          `Invalid item type in element array for ID ${elementId}, template ${component.tmplId}:`,\n                          childElement\n                        );\n                      return;\n                    }\n                    // Append the node to the document fragment\n                    if (child.beforeAppendTo) {\n                      try {\n                        child.beforeAppendTo();\n                      } catch (e) {\n                        console.error(\n                          \"Error in beforeAppendTo (array item):\",\n                          e\n                        );\n                      }\n                    }\n                    if (nodeToAppend) docFragment.appendChild(nodeToAppend);\n                  });\n                  // Replace the placeholder with the document fragment\n                  $tmplElement.parentNode.replaceChild(\n                    docFragment,\n                    $tmplElement\n                  );\n\n                  // Call afterAppendTo for each child\n                  childTarget.forEach(function (child: any) {\n                    if (child && child.afterAppendTo) {\n                      setTimeout(() => {\n                        try {\n                          child.afterAppendTo();\n                        } catch (e) {\n                          console.error(\n                            \"Error in afterAppendTo (array item):\",\n                            e\n                          );\n                        }\n                      }, 0);\n                    }\n                  });\n                  // Handle string, number, or function types\n                } else if (\n                  typeof childTarget === \"string\" ||\n                  typeof childTarget === \"number\"\n                ) {\n                  $tmplElement.parentNode.replaceChild(\n                    stringToElement(childTarget),\n                    $tmplElement\n                  );\n                  // Handle function type\n                } else if (typeof childTarget === \"function\") {\n                  $tmplElement.parentNode.replaceChild(\n                    stringToElement(childTarget()),\n                    $tmplElement\n                  );\n                  // Handle Node or ComponentScope types\n                } else if (\n                  childTarget &&\n                  (childTarget.element || childTarget) instanceof Node\n                ) {\n                  const childScope = childTarget as ComponentScope; // Assume it might be a scope\n                  const childElement = childScope.element || childScope;\n\n                  // Replace the placeholder with the child element\n                  if (childScope.beforeAppendTo) {\n                    try {\n                      childScope.beforeAppendTo();\n                    } catch (e) {\n                      console.error(\"Error in beforeAppendTo:\", e);\n                    }\n                  }\n                  $tmplElement.parentNode.replaceChild(\n                    childElement,\n                    $tmplElement\n                  );\n                  // Call afterAppendTo if available\n                  if (childScope.afterAppendTo) {\n                    setTimeout(() => {\n                      try {\n                        if (childScope.afterAppendTo)\n                          childScope.afterAppendTo();\n                      } catch (e) {\n                        console.error(\"Error in afterAppendTo:\", e);\n                      }\n                    }, 0);\n                  }\n                  // Set parentComponent if it's a component\n                  if (childScope.tmplId) {\n                    childScope.parentComponent = component;\n                  }\n                  // Handle invalid target types\n                } else {\n                  if (configs.debug)\n                    console.warn(\n                      `Invalid target for element insertion ID ${elementId}, template ${component.tmplId}:`,\n                      childTarget\n                    );\n                  $tmplElement.parentNode.removeChild($tmplElement);\n                }\n              } catch (e: any) {\n                console.error(\n                  `Error during element insertion for ID ${elementId}, template ${component.tmplId}:`,\n                  e\n                );\n                if (configs.throwError) throw e;\n                if ($tmplElement && $tmplElement.parentNode) {\n                  try {\n                    $tmplElement.parentNode.removeChild($tmplElement);\n                  } catch (removeError) {\n                    /* Ignore */\n                  }\n                }\n              } // end try\n            }; // end doFunc\n\n            nonblocking === undefined || nonblocking === false\n              ? // Execute immediately or with a delay based on nonblocking\n                doFunc()\n              : setTimeout(\n                  doFunc,\n                  typeof nonblocking === \"number\" ? nonblocking : 0\n                );\n          }); // end forEach\n        },\n      },\n      lazyEvaluate: {\n        pattern: /###([\\s\\S]+?)##/g,\n        exec: function (lazyEvaluate: string): string {\n          const source = `';\\n__lazyScope.lazyEvaluateArray.push(function(data) {${lazyEvaluate}});\\n__p+='`;\n          // Store the lazy evaluation function in lazy scope\n          return source;\n        },\n        lazyExec: function (\n          data: Record<string, any>,\n          lazyScope: LazyScope,\n          component: ComponentScope,\n          wrapper: DocumentFragment | Element\n        ): void {\n          // Execute stored lazy evaluation functions\n          const $childTarget = firstElementChild(wrapper);\n          const $targetElement =\n            childElementCount(wrapper) === 1 ? $childTarget : null;\n          lazyScope.lazyEvaluateArray.forEach(function (\n            selectedFunc: (data: Record<string, any>) => void,\n            idx: number\n          ) {\n            // Call the function with the appropriate context\n            try {\n              selectedFunc.call($targetElement || wrapper, data); // Use wrapper if multiple elements\n            } catch (e: any) {\n              console.error(\n                `Error in lazyEvaluate block ${idx} for template ${component.tmplId}:`,\n                e,\n                selectedFunc\n              );\n              if (configs.throwError) throw e;\n            }\n          });\n          return;\n        },\n      },\n      evaluate: {\n        pattern: /##([\\s\\S]+?)##/g,\n        exec: (evaluate: string): string => {\n          // Insert arbitrary JavaScript code into the template function\n          return \"';\\n\" + evaluate + \"\\n__p+='\";\n        },\n      },\n      escapeSyntax: {\n        pattern: /#\\\\#([\\s\\S]+?)#\\\\#/g,\n        exec: function (syntax) {\n          return `'+\\n'##${syntax}##'+\\n'`;\n        },\n      },\n    },\n    keys: {\n      dataKeyName: \"data\",\n      statusKeyName: \"status\",\n      componentKeyName: \"component\",\n      i18nKeyName: \"i18n\",\n    },\n  };\n};\n\nexport { defaultTemplateEngine };\n","/*\n * Copyright (c) 2025-present, Choi Sungho\n * Code released under the MIT license\n */\n\nimport { CompomintGlobal, ComponentScope, TemplateEngine } from \"./type\";\n\n/**\n * SSR Environment Detection and Configuration\n */\nexport interface SSROptions {\n  renderToString?: boolean;\n  hydrateOnClient?: boolean;\n  generateIds?: boolean;\n  preserveWhitespace?: boolean;\n  lang?: string;\n}\n\nexport interface SSRRenderResult {\n  html: string;\n  css: string;\n  scripts: string[];\n  metadata: {\n    templateIds: string[];\n    componentIds: string[];\n    renderTime: number;\n  };\n}\n\n/**\n * Environment detection utilities\n */\n// Store original window state before SSR setup\nconst _originalWindow = typeof window;\n\nexport const Environment = {\n  // Check if we're in a server environment\n  isServer(): boolean {\n    return (_originalWindow === 'undefined' || (globalThis as any).__SSR_ENVIRONMENT__) &&\n      typeof globalThis !== 'undefined' &&\n      typeof (globalThis as any).process !== 'undefined' &&\n      typeof ((globalThis as any).process as any).versions !== 'undefined' &&\n      !!((globalThis as any).process as any).versions.node;\n  },\n\n  // Check if we're in a browser environment  \n  isBrowser(): boolean {\n    return _originalWindow !== 'undefined' &&\n      typeof document !== 'undefined' &&\n      !(globalThis as any).__SSR_ENVIRONMENT__;\n  },\n\n  // Check if DOM APIs are available\n  hasDOM(): boolean {\n    return typeof document !== 'undefined' &&\n      typeof document.createElement === 'function';\n  },\n\n  // Check if we're in a Node.js environment\n  isNode(): boolean {\n    return typeof (globalThis as any).process !== 'undefined' &&\n      typeof ((globalThis as any).process as any).versions !== 'undefined' &&\n      !!((globalThis as any).process as any).versions.node;\n  }\n};\n\n/**\n * DOM Polyfills for Server-Side Rendering\n */\nexport class SSRDOMPolyfill {\n  private static instance: SSRDOMPolyfill;\n  private elements: Map<string, any> = new Map();\n  private styleCollector: string[] = [];\n  private scriptCollector: string[] = [];\n\n  static getInstance(): SSRDOMPolyfill {\n    if (!SSRDOMPolyfill.instance) {\n      SSRDOMPolyfill.instance = new SSRDOMPolyfill();\n    }\n    return SSRDOMPolyfill.instance;\n  }\n\n  /**\n   * Create a minimal DOM-like element for SSR\n   */\n  createElement(tagName: string): any {\n    const element = {\n      nodeType: 1, // Element nodeType\n      tagName: tagName.toUpperCase(),\n      id: '',\n      className: '',\n      textContent: '',\n      _innerHTML: '',\n      attributes: new Map<string, string>(),\n      children: [] as any[],\n      parentNode: null as any,\n      style: {} as any,\n      dataset: {} as any,\n      firstChild: null as any,\n      lastChild: null as any,\n      childElementCount: 0,\n      firstElementChild: null as any,\n      content: null as any, // For template elements\n\n      // Make childNodes iterable\n      get childNodes() {\n        return this.children;\n      },\n\n      setAttribute(name: string, value: string) {\n        this.attributes.set(name, value);\n        if (name === 'id') this.id = value;\n        if (name === 'class') this.className = value;\n      },\n\n      // Override innerHTML setter to parse HTML\n      set innerHTML(html: string) {\n        this._innerHTML = html;\n        // Clear existing children\n        this.children = [];\n\n        // Parse HTML and create child elements\n        if (html) {\n          this.parseAndCreateChildren(html);\n        }\n      },\n\n      get innerHTML(): string {\n        return this._innerHTML || '';\n      },\n\n      parseAndCreateChildren(html: string) {\n        // Simple HTML parsing for template elements - more flexible regex\n        const templateRegex = /<template[^>]*?id\\s*=\\s*[\"']([^\"']+)[\"'][^>]*?>([\\s\\S]*?)<\\/template>/gi;\n        const scriptRegex = /<script[^>]*?type\\s*=\\s*[\"']text\\/template[\"'][^>]*?id\\s*=\\s*[\"']([^\"']+)[\"'][^>]*?>([\\s\\S]*?)<\\/script>/gi;\n        const scriptCompomintRegex = /<script[^>]*?type\\s*=\\s*[\"']text\\/compomint[\"'][^>]*?id\\s*=\\s*[\"']([^\"']+)[\"'][^>]*?>([\\s\\S]*?)<\\/script>/gi;\n\n        let match;\n\n        // Match template elements\n        templateRegex.lastIndex = 0; // Reset regex\n        while ((match = templateRegex.exec(html)) !== null) {\n          const templateElement = this.createTemplateElement(match[1], match[2]);\n          this.children.push(templateElement);\n          templateElement.parentNode = this;\n        }\n\n        // Match script[type=\"text/template\"] elements\n        scriptRegex.lastIndex = 0; // Reset regex\n        while ((match = scriptRegex.exec(html)) !== null) {\n          const scriptElement = this.createScriptElement(match[1], match[2], 'text/template');\n          this.children.push(scriptElement);\n          scriptElement.parentNode = this;\n        }\n\n        // Match script[type=\"text/compomint\"] elements\n        scriptCompomintRegex.lastIndex = 0; // Reset regex\n        while ((match = scriptCompomintRegex.exec(html)) !== null) {\n          const scriptElement = this.createScriptElement(match[1], match[2], 'text/compomint');\n          this.children.push(scriptElement);\n          scriptElement.parentNode = this;\n        }\n      },\n\n      createTemplateElement(id: string, content: string) {\n        const polyfill = SSRDOMPolyfill.getInstance();\n        const template = polyfill.createElement('template');\n        template.id = id;\n        template.setAttribute('id', id);\n\n        // Unescape HTML entities for template content\n        const unescapedContent = content\n          .replace(/&lt;/g, '<')\n          .replace(/&gt;/g, '>')\n          .replace(/&amp;/g, '&')\n          .replace(/&quot;/g, '\"')\n          .replace(/&#x27;/g, \"'\");\n\n        template._innerHTML = unescapedContent;\n        return template;\n      },\n\n      createScriptElement(id: string, content: string, type: string) {\n        const polyfill = SSRDOMPolyfill.getInstance();\n        const script = polyfill.createElement('script');\n        script.id = id;\n        script.setAttribute('id', id);\n        script.setAttribute('type', type);\n        script._innerHTML = content;\n        return script;\n      },\n\n      getAttribute(name: string): string | null {\n        return this.attributes.get(name) || null;\n      },\n\n      appendChild(child: any) {\n        this.children.push(child);\n        child.parentNode = this;\n        this.firstChild = this.children[0] || null;\n        this.lastChild = this.children[this.children.length - 1] || null;\n        this.childElementCount = this.children.length;\n        this.firstElementChild = this.children[0] || null;\n        return child;\n      },\n\n      removeChild(child: any) {\n        const index = this.children.indexOf(child);\n        if (index > -1) {\n          this.children.splice(index, 1);\n          child.parentNode = null;\n          this.firstChild = this.children[0] || null;\n          this.lastChild = this.children[this.children.length - 1] || null;\n          this.childElementCount = this.children.length;\n          this.firstElementChild = this.children[0] || null;\n        }\n        return child;\n      },\n\n      normalize() {\n        // Mock normalize function\n      },\n\n      querySelector(selector: string): any {\n        // Simple implementation for basic selectors\n        if (selector.startsWith('#')) {\n          const id = selector.substring(1);\n          return this.findById(id);\n        }\n        if (selector.startsWith('.')) {\n          const className = selector.substring(1);\n          return this.findByClass(className);\n        }\n        return this.findByTagName(selector);\n      },\n\n      querySelectorAll(selector: string): any[] {\n        const results: any[] = [];\n\n        // Handle comma-separated selectors\n        const selectors = selector.split(',').map(s => s.trim());\n\n        for (const sel of selectors) {\n          // Check self first\n          if (this.matches && this.matches(sel)) {\n            if (!results.includes(this)) {\n              results.push(this);\n            }\n          }\n\n          // Search children recursively\n          for (const child of this.children) {\n            if (child.querySelectorAll) {\n              const childResults = child.querySelectorAll(sel);\n              for (const result of childResults) {\n                if (!results.includes(result)) {\n                  results.push(result);\n                }\n              }\n            }\n          }\n        }\n\n        return results;\n      },\n\n      matches(selector: string): boolean {\n        const trimmedSelector = selector.trim();\n\n        if (trimmedSelector.startsWith('#')) {\n          return this.id === trimmedSelector.substring(1);\n        }\n        if (trimmedSelector.startsWith('.')) {\n          return this.className.includes(trimmedSelector.substring(1));\n        }\n\n        // Handle attribute selectors like template[id], script[type=\"text/template\"][id]\n        if (trimmedSelector.includes('[') && trimmedSelector.includes(']')) {\n          // Extract tag name if present\n          const tagMatch = trimmedSelector.match(/^(\\w+)(?:\\[|$)/);\n          if (tagMatch) {\n            const expectedTag = tagMatch[1].toLowerCase();\n            if (this.tagName.toLowerCase() !== expectedTag) {\n              return false;\n            }\n          }\n\n          // Extract all attribute selectors\n          const attrMatches = trimmedSelector.match(/\\[([^\\]]+)\\]/g);\n          if (attrMatches) {\n            for (const attrMatch of attrMatches) {\n              // Parse individual attribute selector\n              const attrContent = attrMatch.slice(1, -1); // Remove [ and ]\n\n              if (attrContent.includes('=')) {\n                // Attribute with value like [type=\"text/template\"]\n                const parts = attrContent.split('=');\n                const attrName = parts[0].trim();\n                const attrValue = parts[1].replace(/['\"]/g, '').trim();\n\n                if (this.getAttribute(attrName) !== attrValue) {\n                  return false;\n                }\n              } else {\n                // Attribute without value like [id]\n                const attrName = attrContent.trim();\n                const hasAttr = this.getAttribute(attrName) !== null;\n                if (!hasAttr) {\n                  return false;\n                }\n              }\n            }\n          }\n\n          return true;\n        }\n\n        // Simple tag selector\n        return this.tagName.toLowerCase() === trimmedSelector.toLowerCase();\n      },\n\n      findById(id: string): any {\n        if (this.id === id) return this;\n        for (const child of this.children) {\n          const found = child.findById && child.findById(id);\n          if (found) return found;\n        }\n        return null;\n      },\n\n      findByClass(className: string): any {\n        if (this.className.includes(className)) return this;\n        for (const child of this.children) {\n          const found = child.findByClass && child.findByClass(className);\n          if (found) return found;\n        }\n        return null;\n      },\n\n      findByTagName(tagName: string): any {\n        if (this.tagName === tagName.toUpperCase()) return this;\n        for (const child of this.children) {\n          const found = child.findByTagName && child.findByTagName(tagName);\n          if (found) return found;\n        }\n        return null;\n      },\n\n      // Convert to HTML string\n      toHTML(): string {\n        // Special handling for template elements - return their content\n        if (this.tagName.toLowerCase() === 'template') {\n          if (this.innerHTML) {\n            return this.innerHTML;\n          } else {\n            // Return children content\n            return this.children.map((child: any) =>\n              typeof child === 'string' ? child : child.toHTML ? child.toHTML() : ''\n            ).join('');\n          }\n        }\n\n        let html = `<${this.tagName.toLowerCase()}`;\n\n        // Add attributes\n        for (const [name, value] of this.attributes) {\n          html += ` ${name}=\"${value}\"`;\n        }\n\n        // Self-closing tags\n        if (['img', 'br', 'hr', 'input', 'meta', 'link'].includes(this.tagName.toLowerCase())) {\n          html += ' />';\n          return html;\n        }\n\n        html += '>';\n\n        // Add content\n        if (this.textContent) {\n          html += this.textContent;\n        } else if (this.innerHTML) {\n          html += this.innerHTML;\n        } else {\n          // Add children\n          for (const child of this.children) {\n            if (typeof child === 'string') {\n              html += child;\n            } else if (child.toHTML) {\n              html += child.toHTML();\n            }\n          }\n        }\n\n        html += `</${this.tagName.toLowerCase()}>`;\n        return html;\n      }\n    };\n\n    // Special handling for template elements\n    if (tagName.toLowerCase() === 'template') {\n      element.content = this.createDocumentFragment();\n\n      // Override innerHTML for template elements to populate content\n      const originalSetInnerHTML = element.innerHTML;\n      Object.defineProperty(element, 'innerHTML', {\n        get: function () {\n          return this._innerHTML || '';\n        },\n        set: function (html: string) {\n          this._innerHTML = html;\n          // Clear existing content\n          this.content.children = [];\n\n          // Parse and add to content\n          if (html) {\n            this.parseAndCreateChildren(html);\n            // Copy parsed children to content\n            for (const child of this.children) {\n              this.content.children.push(child);\n              child.parentNode = this.content;\n            }\n            // Update content fragment properties\n            this.content.firstChild = this.content.children[0] || null;\n            this.content.lastChild = this.content.children[this.content.children.length - 1] || null;\n            this.content.childElementCount = this.content.children.length;\n            this.content.firstElementChild = this.content.children[0] || null;\n          }\n        },\n        configurable: true,\n        enumerable: true\n      });\n    }\n\n    return element;\n  }\n\n  /**\n   * Create a document fragment for SSR\n   */\n  createDocumentFragment(): any {\n    return {\n      nodeType: 11, // DocumentFragment nodeType\n      children: [] as any[],\n      firstChild: null as any,\n      lastChild: null as any,\n      childElementCount: 0,\n      firstElementChild: null as any,\n\n      // Make childNodes iterable\n      get childNodes() {\n        return this.children;\n      },\n\n      appendChild(child: any) {\n        this.children.push(child);\n        child.parentNode = this;\n        this.firstChild = this.children[0] || null;\n        this.lastChild = this.children[this.children.length - 1] || null;\n        this.childElementCount = this.children.length;\n        this.firstElementChild = this.children[0] || null;\n        return child;\n      },\n\n      removeChild(child: any) {\n        const index = this.children.indexOf(child);\n        if (index > -1) {\n          this.children.splice(index, 1);\n          child.parentNode = null;\n          this.firstChild = this.children[0] || null;\n          this.lastChild = this.children[this.children.length - 1] || null;\n          this.childElementCount = this.children.length;\n          this.firstElementChild = this.children[0] || null;\n        }\n        return child;\n      },\n\n      normalize() {\n        // Mock normalize function\n      },\n\n      querySelector(selector: string): any {\n        for (const child of this.children) {\n          if (child.querySelector) {\n            const result = child.querySelector(selector);\n            if (result) return result;\n          }\n        }\n        return null;\n      },\n\n      querySelectorAll(selector: string): any[] {\n        const results: any[] = [];\n\n        // Handle comma-separated selectors\n        const selectors = selector.split(',').map(s => s.trim());\n\n        for (const sel of selectors) {\n          // Search children\n          for (const child of this.children) {\n            if (child.querySelectorAll) {\n              const childResults = child.querySelectorAll(sel);\n              for (const result of childResults) {\n                if (!results.includes(result)) {\n                  results.push(result);\n                }\n              }\n            }\n          }\n        }\n\n        return results;\n      },\n\n      toHTML(): string {\n        return this.children.map((child: any) =>\n          typeof child === 'string' ? child : child.toHTML ? child.toHTML() : ''\n        ).join('');\n      }\n    };\n  }\n\n  /**\n   * Create a text node for SSR\n   */\n  createTextNode(text: string): any {\n    return {\n      nodeType: 3,\n      textContent: text,\n      toHTML(): string {\n        return this.textContent;\n      }\n    };\n  }\n\n  /**\n   * Create a comment node for SSR\n   */\n  createComment(text: string): any {\n    return {\n      nodeType: 8,\n      textContent: text,\n      toHTML(): string {\n        return `<!-- ${this.textContent} -->`;\n      }\n    };\n  }\n\n  /**\n   * Collect styles during SSR\n   */\n  collectStyle(css: string): void {\n    this.styleCollector.push(css);\n  }\n\n  /**\n   * Collect scripts during SSR\n   */\n  collectScript(script: string): void {\n    this.scriptCollector.push(script);\n  }\n\n  /**\n   * Get collected styles\n   */\n  getCollectedStyles(): string {\n    return this.styleCollector.join('\\n');\n  }\n\n  /**\n   * Get collected scripts\n   */\n  getCollectedScripts(): string[] {\n    return [...this.scriptCollector];\n  }\n\n  /**\n   * Reset collectors\n   */\n  reset(): void {\n    this.styleCollector = [];\n    this.scriptCollector = [];\n  }\n}\n\n/**\n * SSR Document Mock\n */\nexport function createSSRDocument() {\n  const polyfill = SSRDOMPolyfill.getInstance();\n\n  return {\n    createElement: (tagName: string) => polyfill.createElement(tagName),\n    createDocumentFragment: () => polyfill.createDocumentFragment(),\n    createTextNode: (text: string) => polyfill.createTextNode(text),\n    createComment: (text: string) => polyfill.createComment(text),\n\n    getElementById: (id: string) => null,\n\n    head: {\n      appendChild: (element: any) => {\n        if (element.tagName === 'STYLE') {\n          polyfill.collectStyle(element.textContent || element.innerHTML);\n        } else if (element.tagName === 'SCRIPT') {\n          polyfill.collectScript(element.textContent || element.innerHTML);\n        }\n      },\n      removeChild: () => { },\n      innerHTML: ''\n    },\n\n    body: {\n      appendChild: () => { },\n      removeChild: () => { },\n      innerHTML: '',\n      contains: () => false\n    },\n\n    documentElement: {\n      lang: 'en',\n      getAttribute: function (name: string) {\n        if (name === 'lang') return this.lang;\n        return null;\n      },\n      setAttribute: function (name: string, value: string) {\n        if (name === 'lang') this.lang = value;\n      }\n    }\n  };\n}\n\n/**\n * SSR Window Mock\n */\nexport function createSSRWindow() {\n  return {\n    Node: {\n      prototype: {}\n    },\n    Element: {\n      prototype: {}\n    },\n    CharacterData: {\n      prototype: {}\n    },\n    DocumentType: {\n      prototype: {}\n    },\n    XMLHttpRequest: function () {\n      throw new Error('XMLHttpRequest is not available in SSR environment');\n    }\n  };\n}\n\n/**\n * SSR Element Mock for global scope\n */\nexport function createSSRElementClass() {\n  const SSRElement = class {\n    tagName: string = '';\n    innerHTML: string = '';\n    textContent: string = '';\n    id: string = '';\n    className: string = '';\n    children: any[] = [];\n    parentNode: any = null;\n\n    constructor(tagName?: string) {\n      if (tagName) this.tagName = tagName.toUpperCase();\n    }\n  };\n\n  return SSRElement;\n}\n\n/**\n * Setup SSR environment\n */\nexport function setupSSREnvironment() {\n  if (Environment.isNode()) {\n    // Mark as SSR environment\n    (globalThis as any).__SSR_ENVIRONMENT__ = true;\n\n    // Setup global DOM polyfills\n    const ssrDocument = createSSRDocument();\n    const ssrWindow = createSSRWindow();\n\n    (globalThis as any).document = ssrDocument;\n    (globalThis as any).window = ssrWindow;\n\n    // Also set on global for Node.js compatibility\n    if (typeof (globalThis as any).global !== 'undefined') {\n      ((globalThis as any).global as any).document = ssrDocument;\n      ((globalThis as any).global as any).window = ssrWindow;\n    }\n\n    // Setup global Element, Node classes\n    (globalThis as any).Element = createSSRElementClass();\n    (globalThis as any).Node = class SSRNode { };\n    (globalThis as any).CharacterData = class SSRCharacterData { };\n    (globalThis as any).DocumentType = class SSRDocumentType { };\n\n    // Mock XMLHttpRequest to prevent errors\n    (globalThis as any).XMLHttpRequest = function () {\n      throw new Error('XMLHttpRequest is not available in SSR environment. Use static template rendering instead.');\n    };\n\n    return true;\n  }\n  return false;\n}","/*\n * Copyright (c) 2025-present, Choi Sungho\n * Code released under the MIT license\n */\n\nimport { ComponentScope, CompomintGlobal, TemplateEngine } from \"./type\";\nimport { defaultTemplateEngineSSR } from \"./default-template-engine-ssr\";\nimport {\n  SSROptions,\n  SSRRenderResult,\n  Environment,\n  SSRDOMPolyfill,\n  setupSSREnvironment,\n} from \"./ssr\";\n\n/**\n * Server-Side Rendering Engine for Compomint\n */\nexport class SSRRenderer {\n  private compomint: CompomintGlobal;\n  private options: Required<SSROptions>;\n  private polyfill: SSRDOMPolyfill;\n  private renderStartTime: number = 0;\n\n  constructor(compomint: CompomintGlobal, options: SSROptions = {}) {\n    this.compomint = compomint;\n    this.options = {\n      renderToString: true,\n      hydrateOnClient: false,\n      generateIds: true,\n      preserveWhitespace: false,\n      lang: \"en\",\n      ...options,\n    };\n    this.polyfill = SSRDOMPolyfill.getInstance();\n\n    // Setup SSR environment if needed\n    this.setupEnvironment();\n  }\n\n  private setupEnvironment(): void {\n    if (Environment.isServer()) {\n      setupSSREnvironment();\n\n      // Override compomint's DOM dependencies for SSR\n      this.setupSSROverrides();\n    }\n  }\n\n  private setupSSROverrides(): void {\n    // Store original functions\n    const originalDocument = (globalThis as any).document;\n\n    // Override document.createElement to use our polyfill\n    if (originalDocument) {\n      const originalCreateElement = originalDocument.createElement;\n      originalDocument.createElement = (tagName: string) => {\n        return this.polyfill.createElement(tagName);\n      };\n    }\n  }\n\n  /**\n   * Render a template to HTML string on the server\n   */\n  async renderToString(\n    templateId: string,\n    data: any = {},\n    options: Partial<SSROptions> = {}\n  ): Promise<SSRRenderResult> {\n    this.renderStartTime = Date.now();\n    const mergedOptions = { ...this.options, ...options };\n\n    // Reset polyfill collectors\n    this.polyfill.reset();\n\n    // Set language for i18n if provided\n    if (options.lang) {\n      const doc = (globalThis as any).document;\n      if (doc && doc.documentElement) {\n        doc.documentElement.lang = options.lang;\n      }\n    }\n\n    try {\n      // Get the template metadata\n      const templateMeta = this.compomint.tmplCache.get(templateId);\n      if (!templateMeta || !templateMeta.sourceGenFunc) {\n        throw new Error(\n          `Template \"${templateId}\" not found or missing sourceGenFunc`\n        );\n      }\n\n      // Create SSR-specific data with metadata\n      const ssrData = {\n        ...data,\n        $ssr: true,\n        $generateIds: mergedOptions.generateIds,\n        $hydrateOnClient: mergedOptions.hydrateOnClient,\n      };\n\n      // Call sourceGenFunc directly to get HTML string\n      let result;\n      try {\n        result = templateMeta.sourceGenFunc.call(\n          null, // no this context needed\n          ssrData, // data\n          {}, // status (empty for SSR)\n          { tmplId: templateId }, // component\n          this.compomint.i18n, // i18n (pass full i18n object, not just template-specific)\n          this.compomint, // compomint\n          this.compomint.tmpl || {}, // tmpl\n          {}, // lazyScope (empty for SSR)\n          false // debugger\n        );\n      } catch (error) {\n        throw error;\n      }\n\n      // Convert result to string\n      let html = (\n        typeof result === \"string\" ? result : String(result)\n      ).trim();\n\n      // Parse the rendered HTML to extract and collect styles/scripts\n      html = this.extractStylesAndScripts(html);\n\n      // SSR-specific: Extract styles from original template text since Compomint strips them during compilation\n      if (templateMeta.templateText) {\n        this.extractStylesFromTemplateText(templateMeta.templateText);\n      }\n\n      // Collect styles and scripts\n      const css = this.polyfill.getCollectedStyles();\n      const scripts = this.polyfill.getCollectedScripts();\n\n      // Build metadata\n      const componentId = this.compomint.tools.genId(templateId);\n      const metadata = {\n        templateIds: [templateId],\n        componentIds: [componentId], // Use templateId as component id\n        renderTime: Date.now() - this.renderStartTime,\n      };\n\n      // Add hydration attribute\n      const finalHtml = html.replace(\n        /^(<[a-z]+)/,\n        `$1 data-co-id=\"${componentId}\" data-co-tmpl-id=\"${templateId}\"`\n      );\n\n      return {\n        html: finalHtml || \"\",\n        css,\n        scripts,\n        metadata,\n      };\n    } catch (error) {\n      throw new Error(\n        `SSR rendering failed for template \"${templateId}\": ${error}`\n      );\n    }\n  }\n\n  /**\n   * Render multiple templates and combine results\n   */\n  async renderMultiple(\n    templates: Array<{ id: string; data: any }>,\n    options: Partial<SSROptions> = {}\n  ): Promise<SSRRenderResult> {\n    this.renderStartTime = Date.now();\n    this.polyfill.reset();\n\n    const results: SSRRenderResult[] = [];\n\n    for (const template of templates) {\n      const result = await this.renderToString(\n        template.id,\n        template.data,\n        options\n      );\n      results.push(result);\n    }\n\n    // Combine results\n    const combinedHTML = results.map((r) => r.html).join(\"\\n\");\n    const combinedCSS = results\n      .map((r) => r.css)\n      .filter(Boolean)\n      .join(\"\\n\");\n    const combinedScripts = results.reduce(\n      (acc, r) => acc.concat(r.scripts),\n      [] as string[]\n    );\n    const combinedTemplateIds = results.reduce(\n      (acc, r) => acc.concat(r.metadata.templateIds),\n      [] as string[]\n    );\n    const combinedComponentIds = results.reduce(\n      (acc, r) => acc.concat(r.metadata.componentIds),\n      [] as string[]\n    );\n\n    return {\n      html: combinedHTML,\n      css: combinedCSS,\n      scripts: combinedScripts,\n      metadata: {\n        templateIds: combinedTemplateIds,\n        componentIds: combinedComponentIds,\n        renderTime: Date.now() - this.renderStartTime,\n      },\n    };\n  }\n\n  /**\n   * Generate complete HTML page with SSR content\n   */\n  async renderPage(\n    templateId: string,\n    data: any = {},\n    pageOptions: {\n      title?: string;\n      meta?: Array<{ name?: string; property?: string; content: string }>;\n      links?: Array<{ rel: string; href: string;[key: string]: string }>;\n      scripts?: Array<{ src?: string; content?: string;[key: string]: any }>;\n      bodyClass?: string;\n      lang?: string;\n    } = {}\n  ): Promise<string> {\n    const result = await this.renderToString(templateId, data);\n\n    const {\n      title = \"Compomint SSR Page\",\n      meta = [],\n      links = [],\n      scripts = [],\n      bodyClass = \"\",\n      lang = \"en\",\n    } = pageOptions;\n\n    return `<!DOCTYPE html>\n<html lang=\"${lang}\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>${this.escapeHTML(title)}</title>\n  ${meta\n        .map((m) => {\n          const nameAttr = m.name ? `name=\"${this.escapeHTML(m.name)}\"` : \"\";\n          const propertyAttr = m.property\n            ? `property=\"${this.escapeHTML(m.property)}\"`\n            : \"\";\n          return `<meta ${nameAttr}${propertyAttr} content=\"${this.escapeHTML(\n            m.content\n          )}\">`;\n        })\n        .join(\"\\n  \")}\n  ${links\n        .map((link) => {\n          const attrs = Object.keys(link)\n            .map((key) => `${key}=\"${this.escapeHTML((link as any)[key])}\"`)\n            .join(\" \");\n          return `<link ${attrs}>`;\n        })\n        .join(\"\\n  \")}\n  ${result.css ? `<style>\\n${result.css}\\n</style>` : \"\"}\n</head>\n<body${bodyClass ? ` class=\"${this.escapeHTML(bodyClass)}\"` : \"\"}>\n  ${result.html}\n  ${scripts\n        .map((script) => {\n          if (script.src) {\n            const attrs = Object.keys(script)\n              .map((key) => `${key}=\"${this.escapeHTML((script as any)[key])}\"`)\n              .join(\" \");\n            return `<script ${attrs}></script>`;\n          } else if (script.content) {\n            return `<script>${script.content}</script>`;\n          }\n          return \"\";\n        })\n        .join(\"\\n  \")}\n  ${result.scripts.map((script) => `<script>${script}</script>`).join(\"\\n  \")}\n  ${this.generateHydrationScript(result)}\n</body>\n</html>`;\n  }\n\n  /**\n   * Render component in SSR mode\n   */\n  private async renderComponentSSR(\n    templateFunction: Function,\n    data: any\n  ): Promise<ComponentScope> {\n    // Create a mock container for SSR\n    const mockContainer = this.polyfill.createDocumentFragment();\n\n    // Render the component with SSR-specific handling\n    const component = templateFunction(data, mockContainer) as ComponentScope;\n\n    // If component has async operations, wait for them\n    if (component && typeof component.then === \"function\") {\n      return await component;\n    }\n\n    return component;\n  }\n\n  /**\n   * Extract HTML from rendered component\n   */\n  private extractHTML(component: ComponentScope): string {\n    if (!component || !component.element) {\n      console.warn(\"Component or component.element is missing\");\n      return \"\";\n    }\n\n    // If element has toHTML method (our polyfill), use it\n    if (typeof (component.element as any).toHTML === \"function\") {\n      return (component.element as any).toHTML();\n    }\n\n    // Handle DocumentFragment case\n    if ((component.element as any).nodeType === 11) {\n      // DocumentFragment\n      // For DocumentFragment, we need to extract HTML from children\n      const children = (component.element as any).childNodes || [];\n      return Array.from(children)\n        .map((child: any) => {\n          if (typeof child.toHTML === \"function\") {\n            return child.toHTML();\n          } else if (child.innerHTML) {\n            return child.innerHTML;\n          } else if (child.textContent) {\n            return child.textContent;\n          } else if (child.nodeType === 3) {\n            // Text node\n            return child.textContent || \"\";\n          }\n          return \"\";\n        })\n        .join(\"\");\n    }\n\n    // Fallback for other cases\n    if (component.element.innerHTML) {\n      return component.element.innerHTML;\n    }\n\n    if (component.element.textContent) {\n      return component.element.textContent;\n    }\n\n    return \"\";\n  }\n\n  /**\n   * Generate hydration script for client-side\n   */\n  private generateHydrationScript(result: SSRRenderResult): string {\n    if (!this.options.hydrateOnClient) {\n      return \"\";\n    }\n\n    const hydrationData = {\n      templateIds: result.metadata.templateIds,\n      componentIds: result.metadata.componentIds,\n      renderTime: result.metadata.renderTime,\n    };\n\n    return `\n<script>\n  // Compomint SSR Hydration Data\n  window.__COMPOMINT_SSR__ = ${JSON.stringify(hydrationData)};\n  \n  // Hydration helper\n  window.__COMPOMINT_HYDRATE__ = function(compomint) {\n    console.log('Hydrating Compomint SSR components...', window.__COMPOMINT_SSR__);\n    // Additional hydration logic can be added here\n  };\n</script>`;\n  }\n\n  /**\n   * Escape HTML for safe output\n   */\n  private escapeHTML(text: string): string {\n    const escapeMap: { [key: string]: string } = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&#x27;\",\n    };\n\n    return text.replace(/[&<>\"']/g, (char) => escapeMap[char] || char);\n  }\n\n  /**\n   * Extract styles and scripts from rendered HTML and remove them\n   */\n  private extractStylesAndScripts(html: string): string {\n    // Extract and remove styles\n    const styleRegex = /<style[^>]*>([\\s\\S]*?)<\\/style>/gi;\n    html = html.replace(styleRegex, (match, css) => {\n      if (css && css.trim()) {\n        this.polyfill.collectStyle(css.trim());\n      }\n      return \"\"; // Remove style tag\n    });\n\n    // Extract and remove scripts (but keep them in HTML for now to satisfy tests)\n    const scriptRegex =\n      /<script[^>]*(?:src\\s*=\\s*[\"'][^\"']*[\"'])?[^>]*>([\\s\\S]*?)<\\/script>/gi;\n    html.replace(scriptRegex, (match, content) => {\n      const script = content.trim();\n      if (script) {\n        this.polyfill.collectScript(script);\n      }\n      return match; // Keep script tag\n    });\n\n    return html;\n  }\n\n  /**\n   * Extract styles from original template text (SSR-specific workaround)\n   * This is needed because Compomint strips <style> tags during template compilation\n   */\n  private extractStylesFromTemplateText(templateText: string): void {\n    // Decode HTML entities first\n    const decodedText = templateText\n      .replace(/&lt;/g, \"<\")\n      .replace(/&gt;/g, \">\")\n      .replace(/&amp;/g, \"&\")\n      .replace(/&quot;/g, '\"')\n      .replace(/&#x27;/g, \"'\");\n\n    // Extract styles from decoded template text\n    const styleRegex = /<style[^>]*>([\\s\\S]*?)<\\/style>/gi;\n    let styleMatch;\n    while ((styleMatch = styleRegex.exec(decodedText)) !== null) {\n      const css = styleMatch[1].trim();\n      if (css) {\n        this.polyfill.collectStyle(css);\n      }\n    }\n  }\n\n  /**\n   * Get renderer statistics\n   */\n  getStats(): {\n    environment: string;\n    polyfillActive: boolean;\n    lastRenderTime: number;\n  } {\n    return {\n      environment: Environment.isServer() ? \"server\" : \"client\",\n      polyfillActive: Environment.isServer(),\n      lastRenderTime: this.renderStartTime\n        ? Date.now() - this.renderStartTime\n        : 0,\n    };\n  }\n}\n\n/**\n * Create SSR renderer instance\n */\nexport function createSSRRenderer(\n  compomint: CompomintGlobal,\n  options: SSROptions = {}\n): SSRRenderer {\n  return new SSRRenderer(compomint, options);\n}\n\n/**\n * Quick SSR render function\n */\nexport async function renderToString(\n  compomint: CompomintGlobal,\n  templateId: string,\n  data: any = {},\n  options: SSROptions = {}\n): Promise<string> {\n  const renderer = createSSRRenderer(compomint, options);\n  const result = await renderer.renderToString(templateId, data, options);\n  return result.html;\n}\n","/*\n * Copyright (c) 2025-present, Choi Sungho\n * Code released under the MIT license\n */\n\nimport {\n  CompomintGlobal,\n  ComponentScope,\n  LazyScope,\n  RenderingFunction,\n  TemplateEngine,\n  TemplateMeta,\n  TemplateRule,\n  Tools,\n  TemplateElement,\n  CompomintConfigs,\n} from \"./type\";\nimport { defaultTemplateEngine } from \"./default-template-engine\";\nimport { applyBuiltInTemplates } from \"./built-in-templates\";\nimport { firstElementChild, childElementCount, cleanNode } from \"./utils\";\nimport { Environment, setupSSREnvironment, SSRDOMPolyfill } from \"./ssr\";\nimport { SSRRenderer, createSSRRenderer } from \"./ssr-renderer\";\nimport { defaultTemplateEngineSSR } from \"./default-template-engine-ssr\";\n\n// Polyfill for Object.assign\nif (typeof Object.assign != \"function\") {\n  Object.defineProperty(Object, \"assign\", {\n    value: function assign(target: any, ...params: any[]) {\n      if (target == null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n      }\n      const to = Object(target);\n      for (let index = 0, length = params.length; index < length; index++) {\n        const nextSource = params[index];\n        if (nextSource != null) {\n          for (let nextKey in nextSource) {\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    },\n    writable: true,\n    configurable: true,\n  });\n}\n\n// Polyfill for ChildNode.remove\n(function (arr: any[]) {\n  arr.forEach(function (item) {\n    if (!item || item.hasOwnProperty(\"remove\")) {\n      return;\n    }\n    Object.defineProperty(item, \"remove\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function remove() {\n        if (this.parentNode !== null) {\n          this.parentNode.removeChild(this);\n        }\n      },\n    });\n  });\n})(\n  [\n    typeof Element !== \"undefined\" ? Element.prototype : {},\n    typeof CharacterData !== \"undefined\" ? CharacterData.prototype : {},\n    typeof DocumentType !== \"undefined\" ? DocumentType.prototype : {},\n  ].filter(Boolean)\n);\n\n// Polyfill for Node.isConnected\n(function (supported: boolean) {\n  if (supported || typeof window === \"undefined\" || !window.Node) return;\n  Object.defineProperty(window.Node.prototype, \"isConnected\", {\n    get: function (): boolean {\n      return document.body.contains(this);\n    },\n  });\n})(\n  typeof window !== \"undefined\" &&\n  window.Node &&\n  \"isConnected\" in window.Node.prototype\n);\n\nconst compomint = {} as CompomintGlobal;\nconst tmpl = {} as Record<string, any>;\nconst tools = (compomint.tools = compomint.tools || ({} as Tools));\nconst configs: CompomintConfigs = (compomint.configs = Object.assign(\n  { printExecTime: false, debug: false, throwError: true },\n  compomint.configs\n));\nconst cachedTmpl = (compomint.tmplCache =\n  compomint.tmplCache || new Map<string, TemplateMeta>());\nif (!cachedTmpl.has(\"anonymous\")) {\n  cachedTmpl.set(\"anonymous\", { elements: new Set() } as TemplateMeta); // Cast to TemplateMeta\n}\nconst isSupportTemplateTag =\n  typeof document !== \"undefined\" &&\n  \"content\" in document.createElement(\"template\");\n\nconst noMatch = /(.)^/;\nconst escapes: Record<string, string> = {\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\",\n  \"\\r\": \"\\\\r\",\n  \"\\n\": \"\\\\n\",\n  \"\\t\": \"\\\\t\",\n  \"\\u2028\": \"\\u2028\",\n  \"\\u2029\": \"\\u2029\",\n  \"><\": \"><\",\n  \"<\": \"<\",\n  \">\": \">\",\n};\n\nconst escaper = /\\>( |\\n)+\\<|\\>( |\\n)+|( |\\n)+\\<|\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n// set default template config\nif (Environment.isServer()) {\n  compomint.templateEngine = defaultTemplateEngineSSR(compomint);\n} else {\n  compomint.templateEngine = defaultTemplateEngine(compomint);\n}\n\nconst escapeHtml = (function () {\n  const escapeMap: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\", // Use HTML entity for single quote\n    \"`\": \"&#x60;\", // Use HTML entity for backtick\n    //\"\\n\": \"&#10;\", // Keep newline escaping if needed, otherwise remove\n  };\n\n  const unescapeMap: Record<string, string> = Object.keys(escapeMap).reduce(\n    (acc: Record<string, string>, key: string) => {\n      acc[escapeMap[key]] = key;\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  const createEscaper = function (\n    map: Record<string, string>\n  ): (str: string) => string {\n    const escaper = function (match: string): string {\n      return map[match];\n    };\n    const source = `(?:${Object.keys(map).join(\"|\").replace(/\\\\/g, \"\\\\\\\\\")})`; // Escape backslashes if any keys have them\n    const testRegexp = RegExp(source);\n    const replaceRegexp = RegExp(source, \"g\");\n    return function (string: string | null | undefined): string {\n      string = string == null ? \"\" : `${string}`;\n      return testRegexp.test(string)\n        ? string.replace(replaceRegexp, escaper)\n        : string;\n    };\n  };\n\n  return {\n    escape: createEscaper(escapeMap),\n    unescape: createEscaper(unescapeMap),\n  };\n})();\ntools.escapeHtml = escapeHtml;\n\nconst matcherFunc = function (templateRules: Record<string, TemplateRule>): {\n  templateRules: Record<string, TemplateRule>;\n  pattern: RegExp;\n  exec: ((...args: any[]) => string)[];\n  lazyExecKeys: string[];\n  lazyExec: Record<\n    string,\n    (\n      data: Record<string, any>,\n      lazyScope: LazyScope,\n      component: ComponentScope,\n      wrapper: DocumentFragment | Element\n    ) => void\n  >;\n  lazyScopeSeed: string;\n} {\n  const patternArray: string[] = [];\n  const execArray: ((...args: any[]) => string)[] = [];\n  const lazyExecMap: Record<\n    string,\n    (\n      data: Record<string, any>,\n      lazyScope: LazyScope,\n      component: ComponentScope,\n      wrapper: DocumentFragment | Element\n    ) => void\n  > = {};\n  const lazyScopeSeed: Record<string, any[]> = {};\n\n  Object.keys(templateRules).forEach(function (key) {\n    const templateRule = templateRules[key] as TemplateRule | any; // Type assertion\n    if (\n      templateRule &&\n      typeof templateRule === \"object\" &&\n      templateRule.pattern instanceof RegExp &&\n      typeof templateRule.exec === \"function\"\n    ) {\n      patternArray.push((templateRule.pattern || noMatch).source);\n      execArray.push(templateRule.exec);\n    }\n    if (\n      templateRule &&\n      typeof templateRule === \"object\" &&\n      typeof templateRule.lazyExec === \"function\"\n    ) {\n      const arrayKey = `${key}Array`;\n      lazyExecMap[arrayKey] = templateRule.lazyExec;\n      lazyScopeSeed[arrayKey] = [];\n    }\n  });\n  return {\n    templateRules: templateRules,\n    pattern: new RegExp(patternArray.join(\"|\"), \"g\"),\n    exec: execArray,\n    lazyExecKeys: Object.keys(lazyScopeSeed),\n    lazyExec: lazyExecMap,\n    lazyScopeSeed: JSON.stringify(lazyScopeSeed),\n  };\n};\n\nconst escapeFunc = function (match: string): string {\n  return escapes[match] || escapes[match.replace(/[ \\n]/g, \"\")] || \"\";\n};\n\nconst defaultMatcher = matcherFunc(compomint.templateEngine.rules);\n\nconst templateParser = function (\n  tmplId: string,\n  text: string,\n  matcher: ReturnType<typeof matcherFunc>\n): string {\n  if (configs.printExecTime) console.time(`tmpl: ${tmplId}`);\n\n  let index = 0;\n  let source = \"\";\n\n  text.replace(matcher.pattern, function (...params: any[]): string {\n    const match: string = params[0];\n    const offset: number = params[params.length - 2];\n\n    source += text.slice(index, offset).replace(escaper, escapeFunc);\n\n    let selectedMatchContent: string | undefined;\n    let matchIndex: number | null = null;\n\n    params.slice(1, -2).some(function (value: any, idx: number) {\n      if (value !== undefined) {\n        selectedMatchContent = value;\n        matchIndex = idx;\n        return true;\n      }\n      return false;\n    });\n\n    if (selectedMatchContent !== undefined && matchIndex !== null) {\n      try {\n        source += matcher.exec[matchIndex].call(\n          matcher.templateRules,\n          selectedMatchContent,\n          tmplId\n        );\n      } catch (e: any) {\n        console.error(\n          `Error executing template rule index ${matchIndex} for match \"${selectedMatchContent}\" in template \"${tmplId}\":`,\n          e\n        );\n        if (configs.throwError) throw e;\n        source += \"\";\n      }\n    } else {\n      source += match.replace(escaper, escapeFunc);\n    }\n\n    index = offset + match.length;\n    return match;\n  });\n\n  source += text.slice(index).replace(escaper, escapeFunc);\n\n  if (configs.printExecTime) console.timeEnd(`tmpl: ${tmplId}`);\n  return source;\n};\n\nconst templateBuilder = (compomint.template =\n  function compomint_templateBuilder(\n    tmplId: string,\n    templateText: string,\n    customTemplateEngine?: Partial<TemplateEngine>\n  ): RenderingFunction {\n    let templateEngine = compomint.templateEngine;\n    let matcher = defaultMatcher;\n\n    if (customTemplateEngine) {\n      templateEngine = {\n        rules: Object.assign(\n          {},\n          templateEngine.rules,\n          customTemplateEngine.rules || {}\n        ),\n        keys: Object.assign(\n          {},\n          templateEngine.keys,\n          customTemplateEngine.keys || {}\n        ),\n      };\n      matcher = matcherFunc(templateEngine.rules);\n    }\n\n    const source = `\n/* tmplId: ${tmplId} */\n//# sourceURL=http://tmpl//${tmplId.split(\"-\").join(\"//\")}.js\n// if (__debugger) {\n// debugger;\n// }\nlet __p='';\n__p+='${templateParser(tmplId, templateText, matcher)}';\nreturn __p;`;\n\n    let sourceGenFunc: Function | null = null;\n\n    try {\n      sourceGenFunc = new Function(\n        templateEngine.keys.dataKeyName as string,\n        templateEngine.keys.statusKeyName as string,\n        templateEngine.keys.componentKeyName as string,\n        templateEngine.keys.i18nKeyName as string,\n        \"compomint\",\n        \"tmpl\",\n        \"__lazyScope\",\n        \"__debugger\",\n        source\n      );\n    } catch (e: any) {\n      if (configs.throwError) {\n        console.error(\n          `Template compilation error in \"${tmplId}\", ${e.name}: ${e.message}`\n        );\n        try {\n          // Attempt re-run for potential browser debugging\n          new Function(\n            templateEngine.keys.dataKeyName as string,\n            templateEngine.keys.statusKeyName as string,\n            templateEngine.keys.componentKeyName as string,\n            templateEngine.keys.i18nKeyName as string,\n            \"compomint\",\n            \"tmpl\",\n            \"__lazyScope\",\n            \"__debugger\",\n            source\n          );\n        } catch {\n          /* Ignore re-run error */\n        }\n        throw e;\n      } else {\n        return () => ({} as ComponentScope); // Return a dummy function if not throwing\n      }\n    }\n\n    const renderingFunc: RenderingFunction =\n      function compomint_renderingFuncBuilder(...params): ComponentScope {\n        let data: Record<string, any>;\n        let wrapperElement: Element | undefined;\n        let callback: ((component: ComponentScope) => void) | undefined;\n        let baseComponent: Partial<ComponentScope> | undefined;\n        let existingElement: HTMLElement | undefined;\n\n        // Argument parsing logic\n        const firstArg = params[0];\n        if (\n          firstArg &&\n          typeof firstArg === \"object\" &&\n          (firstArg.$wrapperElement ||\n            firstArg.$callback ||\n            firstArg.$baseComponent ||\n            firstArg.$existingElement)\n        ) {\n          data = { ...firstArg }; // Clone data object\n          wrapperElement = data.$wrapperElement;\n          delete data.$wrapperElement;\n          callback = data.$callback;\n          delete data.$callback;\n          baseComponent = data.$baseComponent;\n          delete data.$baseComponent;\n          existingElement = data.$existingElement;\n          delete data.$existingElement;\n        } else {\n          data = firstArg;\n          if (typeof params[1] === \"function\") {\n            wrapperElement = undefined;\n            callback = params[1] as (component: ComponentScope) => void;\n            baseComponent = params[2];\n          } else {\n            wrapperElement = params[1];\n            callback = params[2];\n            baseComponent = params[3];\n          }\n        }\n\n        const dataKeyName = templateEngine.keys.dataKeyName as string;\n        const statusKeyName = templateEngine.keys.statusKeyName as string;\n        const lazyScope: LazyScope = JSON.parse(matcher.lazyScopeSeed);\n\n        const component: ComponentScope = Object.assign(baseComponent || {}, {\n          tmplId: tmplId,\n          element: null as any, // Initialize element\n          status: (baseComponent && baseComponent.status) || {}, // Ensure status exists\n          replace: function (newComponent: ComponentScope | Element): void {\n            const self = this as ComponentScope;\n            if (\n              !self.element ||\n              !(self.element instanceof Node) ||\n              !self.element.parentElement\n            ) {\n              if (configs.debug)\n                console.warn(\n                  `Cannot replace template \"${tmplId}\": element not in DOM.`\n                );\n              return;\n            }\n            self.element.parentElement.replaceChild(\n              (newComponent as ComponentScope).element ||\n              (newComponent as Element),\n              self.element as Node\n            );\n          },\n          remove: function (\n            spacer: boolean = false\n          ): Element | TemplateElement | Comment | DocumentFragment {\n            const self = this as ComponentScope;\n            if (self.beforeRemove) {\n              try {\n                self.beforeRemove();\n              } catch (e) {\n                console.error(\"Error in beforeRemove:\", e);\n              }\n            }\n\n            // Remote event event listener\n            // Iterate through all event handlers stored in lazyScope.eventArray\n            if (lazyScope.eventArray) {\n              lazyScope.eventArray.forEach(function (event) {\n                // For each event entry, iterate through its associated event listeners\n                event.forEach(function (selectedEvent: Record<string, any>) {\n                  if (selectedEvent.element) {\n                    if (typeof selectedEvent.eventFunc === \"function\") {\n                      selectedEvent.element.removeEventListener(\n                        \"click\",\n                        selectedEvent.eventFunc as EventListenerOrEventListenerObject\n                      ); // Remove click event listener\n                    } else {\n                      Object.keys(selectedEvent.eventFunc).forEach(function (\n                        eventType\n                      ) {\n                        selectedEvent.element.removeEventListener(\n                          eventType,\n                          (\n                            selectedEvent.eventFunc as Record<\n                              string,\n                              EventListenerOrEventListenerObject\n                            >\n                          )[eventType]\n                        );\n                      });\n                    }\n                    Object.keys(selectedEvent).forEach(\n                      (key) => delete selectedEvent[key]\n                    );\n                  }\n                  // Clear the selectedEvent object to release references\n                });\n              });\n            }\n\n            const parent =\n              self.element instanceof Node ? self.element.parentElement : null;\n            const removedElement:\n              | Element\n              | TemplateElement\n              | Comment\n              | DocumentFragment = self.element; // Store reference\n\n            if (parent) {\n              if (spacer) {\n                const dumy = document.createElement(\"template\");\n                parent.replaceChild(dumy, self.element as Node);\n                self.element = dumy; // Update scope's element reference\n              } else {\n                parent.removeChild(self.element as Node);\n              }\n            } else if (configs.debug) {\n              console.warn(\n                `Cannot remove template \"${tmplId}\": element not in DOM.`\n              );\n            }\n\n            if (self.afterRemove) {\n              try {\n                self.afterRemove();\n              } catch (e) {\n                console.error(\"Error in afterRemove:\", e);\n              }\n            }\n            return removedElement;\n          },\n          appendTo: function (parentElement: Element): ComponentScope {\n            const self = this as ComponentScope;\n            if (self.beforeAppendTo) {\n              try {\n                self.beforeAppendTo();\n              } catch (e) {\n                console.error(\"Error in beforeAppendTo:\", e);\n              }\n            }\n\n            if (parentElement && self.element instanceof Node) {\n              parentElement.appendChild(self.element);\n            } else if (configs.debug) {\n              console.warn(\n                `Cannot append template \"${tmplId}\": parentElement or scope.element is missing or not a Node.`\n              );\n            }\n\n            if (self.afterAppendTo) {\n              setTimeout(() => {\n                try {\n                  self.afterAppendTo!();\n                } catch (e) {\n                  console.error(\"Error in afterAppendTo:\", e);\n                }\n              }, 0);\n            }\n            return self;\n          },\n          release: function (): void {\n            /* Implementation below */\n          },\n          render: function (newData: Record<string, any>): ComponentScope {\n            /* Implementation below */ return this;\n          },\n          refresh: function (reflashData: Record<string, any>): ComponentScope {\n            /* Implementation below */ return this;\n          },\n          reflash: function (reflashData: Record<string, any>): ComponentScope {\n            /* Implementation below */ return this;\n          },\n        } as ComponentScope); // Cast to ComponentScope\n\n        if (!component._id) {\n          component._id = tools.genId(tmplId);\n        }\n        component[dataKeyName] = data;\n        if (component[statusKeyName] == undefined) {\n          component[statusKeyName] = {};\n        }\n\n        const hasParent = wrapperElement instanceof Element;\n        const temp = document.createElement(\"template\");\n\n        if (configs.printExecTime) console.time(`render: ${tmplId}`);\n\n        let returnTarget: Node | null = null;\n        let renderedHTML: string | null = null;\n        try {\n          renderedHTML = !data\n            ? `<template data-co-empty-template=\"${tmplId}\"></template>`\n            : sourceGenFunc!.call(\n              // Use non-null assertion\n              wrapperElement || null,\n              data,\n              component[statusKeyName],\n              component,\n              compomint.i18n[tmplId],\n              compomint,\n              tmpl,\n              lazyScope,\n              configs.debug // Pass debug flag for __debugger\n            );\n        } catch (e: any) {\n          if (configs.throwError) {\n            console.error(\n              `Runtime error during render of \"${tmplId}\":`,\n              e.message\n            );\n            console.debug(\"--- Data ---\", data, \"------------\");\n            try {\n              // Attempt re-run with debugger\n              sourceGenFunc!.call(\n                wrapperElement || null,\n                data,\n                component[statusKeyName],\n                component,\n                compomint.i18n[tmplId],\n                lazyScope,\n                true\n              );\n            } catch {\n              /* Ignore */\n            }\n            throw e;\n          } else {\n            console.warn(\n              `Render failed for \"${tmplId}\". Returning scope with comment node.`\n            );\n            component.element = document.createComment(\n              `Render Error: ${tmplId}`\n            ) as any;\n            return component;\n          }\n        }\n        if (configs.printExecTime) console.timeEnd(`render: ${tmplId}`);\n\n        temp.innerHTML = renderedHTML!;\n        let docFragment: DocumentFragment | Element | TemplateElement =\n          temp.content || temp;\n\n        if (\n          (docFragment as any).tagName == \"TEMPLATE\" &&\n          !(temp as any).content\n        ) {\n          // Check for IE11 case\n          const children = Array.from(docFragment.childNodes);\n          docFragment = document.createDocumentFragment();\n          children.forEach((child) => docFragment.appendChild(child));\n        }\n\n        if (hasParent && wrapperElement) {\n          while (wrapperElement.firstChild) {\n            wrapperElement.removeChild(wrapperElement.firstChild);\n          }\n          component.wrapperElement = wrapperElement;\n        }\n\n        // Handle shadow DOM creation\n        const shadowStyle = (docFragment as any).querySelector\n          ? (docFragment as any).querySelector(\"style\")\n          : null;\n        if (shadowStyle && (docFragment as any).querySelector) {\n          // Check if querySelector exists\n\n          // In SSR environment, collect styles instead of creating shadow DOM\n          if (Environment.isServer()) {\n            // Extract and collect all styles for SSR\n            const styles = (docFragment as any).querySelectorAll(\"style\");\n            styles.forEach((style: any) => {\n              const css = style.textContent || style.innerHTML;\n              if (\n                css &&\n                (globalThis as any).document &&\n                (globalThis as any).document.head\n              ) {\n                // Use SSR polyfill to collect styles\n                const polyfill = SSRDOMPolyfill.getInstance();\n                polyfill.collectStyle(css);\n\n                // Remove style from the fragment so it doesn't appear in the rendered HTML\n                style.remove();\n              }\n            });\n            // Don't create shadow DOM in SSR, leave styles in place for extraction\n          } else {\n            // Browser environment - create shadow DOM as usual\n            const host = document.createElement(tmplId); // Use tmplId as host tag name\n            try {\n              const shadow = host.attachShadow({ mode: \"open\" });\n              while (docFragment.firstChild) {\n                shadow.appendChild(docFragment.firstChild);\n              }\n              docFragment = host; // Replace fragment with the host element\n            } catch (e) {\n              console.error(\n                `Failed to attach shadow DOM for template \"${tmplId}\":`,\n                e\n              );\n              // Proceed without shadow DOM if attachShadow fails\n            }\n          }\n        }\n\n        if (docFragment.firstChild && docFragment.firstChild.nodeType == 8) {\n          returnTarget = docFragment.firstChild;\n        } else if (childElementCount(docFragment) == 1) {\n          returnTarget = firstElementChild(docFragment);\n          if (hasParent && wrapperElement && returnTarget) {\n            if (component.beforeAppendTo) {\n              try {\n                component.beforeAppendTo();\n              } catch (e) {\n                console.error(\"Error in beforeAppendTo:\", e);\n              }\n            }\n            wrapperElement.appendChild(returnTarget);\n            if (component.afterAppendTo) {\n              setTimeout(() => {\n                try {\n                  component.afterAppendTo!();\n                } catch (e) {\n                  console.error(\"Error in afterAppendTo:\", e);\n                }\n              }, 0);\n            }\n          }\n        } else {\n          if (hasParent && wrapperElement) {\n            if (component.beforeAppendTo) {\n              try {\n                component.beforeAppendTo();\n              } catch (e) {\n                console.error(\"Error in beforeAppendTo:\", e);\n              }\n            }\n            wrapperElement.appendChild(docFragment);\n            if (component.afterAppendTo) {\n              setTimeout(() => {\n                try {\n                  component.afterAppendTo!();\n                } catch (e) {\n                  console.error(\"Error in afterAppendTo:\", e);\n                }\n              }, 0);\n            }\n            returnTarget = wrapperElement;\n          } else {\n            returnTarget = docFragment;\n          }\n        }\n\n        if (data && data.$props && returnTarget instanceof Element) {\n          for (const prop in data.$props) {\n            try {\n              const value = data.$props[prop];\n              if (prop.startsWith(\"data-\")) {\n                const camelCased = prop\n                  .substring(5)\n                  .replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n                (returnTarget as HTMLElement).dataset[camelCased] =\n                  String(value);\n              } else if (prop in returnTarget) {\n                (returnTarget as any)[prop] = value;\n              } else {\n                returnTarget.setAttribute(prop, String(value));\n              }\n            } catch (e: any) {\n              console.error(\n                `Error applying prop \"${prop}\" to element in template \"${tmplId}\":`,\n                e\n              );\n            }\n          }\n        }\n\n        if (returnTarget instanceof Node && returnTarget.normalize) {\n          returnTarget.normalize();\n        }\n        if (returnTarget instanceof Node) {\n          cleanNode(returnTarget);\n        }\n\n        if (existingElement) {\n          component.element = existingElement;\n        } else {\n          component.element = returnTarget as HTMLElement | TemplateElement; // Assign final element/fragment\n        }\n\n        // Execute lazyExec functions after element is attached\n        const lazyExec = matcher.lazyExec;\n        if (data) {\n          matcher.lazyExecKeys.forEach(function (key) {\n            if (lazyScope[key] && lazyScope[key].length > 0) {\n              try {\n                lazyExec[key].call(\n                  templateEngine.rules[key.slice(0, -5)],\n                  data,\n                  lazyScope,\n                  component,\n                  docFragment as DocumentFragment | Element\n                ); // Cast needed\n              } catch (e: any) {\n                if (configs.throwError) {\n                  console.error(\n                    `Error during lazy execution of \"${key}\" for template \"${tmplId}\":`,\n                    e\n                  );\n                  throw e;\n                }\n              }\n            }\n          });\n        }\n\n        if (tools.liveReloadSupport) {\n          try {\n            tools.liveReloadSupport(component);\n          } catch (e) {\n            console.error(\"Error in liveReloadSupport:\", e);\n          }\n        }\n\n        if (callback) {\n          try {\n            callback.call(wrapperElement || null, component);\n          } catch (e: any) {\n            console.error(`Error in template callback for \"${tmplId}\":`, e);\n            if (configs.throwError) throw e;\n          }\n        }\n\n        // Define Component Methods (Render/Refresh/Release)\n        component.release = function (): void {\n          const self = this as ComponentScope;\n          const props = Object.getOwnPropertyNames(self);\n          const keepProps = [statusKeyName, \"_id\"];\n          for (let i = 0; i < props.length; i++) {\n            const prop = props[i];\n            if (\n              typeof (self as any)[prop] !== \"function\" &&\n              !keepProps.includes(prop)\n            ) {\n              delete (self as any)[prop];\n            }\n          }\n        };\n\n        component.render = function (\n          newData: Record<string, any>\n        ): ComponentScope {\n          const currentComponent = this as ComponentScope;\n          const targetElement = currentComponent.element;\n          const parent =\n            targetElement instanceof Node ? targetElement.parentElement : null;\n          const wrapper = currentComponent.wrapperElement;\n          const tmplFunc = compomint.tmpl(currentComponent.tmplId);\n\n          if (!tmplFunc) {\n            console.error(\n              `Cannot re-render: Template function for \"${currentComponent.tmplId}\" not found.`\n            );\n            return currentComponent;\n          }\n\n          const hooks = {\n            beforeAppendTo: currentComponent.beforeAppendTo,\n            afterAppendTo: currentComponent.afterAppendTo,\n            beforeRemove: currentComponent.beforeRemove,\n            afterRemove: currentComponent.afterRemove,\n            beforeRefresh: currentComponent.beforeRefresh,\n            afterRefresh: currentComponent.afterRefresh,\n          };\n\n          if (currentComponent.beforeRemove) {\n            try {\n              currentComponent.beforeRemove();\n            } catch (e) {\n              console.error(\"Error in beforeRemove during render:\", e);\n            }\n          }\n\n          let newComponent: ComponentScope;\n          if (wrapper) {\n            newComponent = tmplFunc(\n              newData,\n              wrapper,\n              undefined,\n              currentComponent\n            ); // Reuse scope object\n          } else if (parent && targetElement instanceof Node) {\n            newComponent = tmplFunc(\n              newData,\n              undefined,\n              undefined,\n              currentComponent\n            ); // Reuse scope object\n            if (newComponent.element instanceof Node) {\n              if (newComponent.beforeAppendTo) {\n                try {\n                  newComponent.beforeAppendTo();\n                } catch (e) {\n                  console.error(\"Error in beforeAppendTo during render:\", e);\n                }\n              }\n              parent.replaceChild(newComponent.element, targetElement);\n              if (newComponent.afterAppendTo) {\n                setTimeout(() => {\n                  try {\n                    newComponent.afterAppendTo!();\n                  } catch (e) {\n                    console.error(\"Error in afterAppendTo during render:\", e);\n                  }\n                }, 0);\n              }\n            } else if (configs.debug) {\n              console.warn(\n                `Re-render of \"${currentComponent.tmplId}\" resulted in no element or target was missing.`\n              );\n            }\n          } else {\n            // No parent, just create new scope (likely detached)\n            newComponent = tmplFunc(\n              newData,\n              undefined,\n              undefined,\n              currentComponent\n            );\n          }\n\n          if (currentComponent.afterRemove) {\n            try {\n              currentComponent.afterRemove();\n            } catch (e) {\n              console.error(\"Error in afterRemove during render:\", e);\n            }\n          }\n\n          Object.assign(newComponent, hooks); // Restore hooks\n          return newComponent;\n        };\n\n        component.refresh = function (\n          reflashData: Record<string, any>\n        ): ComponentScope {\n          const currentComponent = this as ComponentScope;\n          const currentData = currentComponent[dataKeyName];\n          if (currentComponent.beforeRefresh) {\n            try {\n              currentComponent.beforeRefresh();\n            } catch (e) {\n              console.error(\"Error in beforeRefresh:\", e);\n            }\n          }\n          const newData = Object.assign({}, currentData || {}, reflashData);\n          const newComponent = currentComponent.render(newData);\n          if (currentComponent.afterRefresh) {\n            try {\n              currentComponent.afterRefresh();\n            } catch (e) {\n              console.error(\"Error in afterRefresh:\", e);\n            }\n          }\n          return newComponent;\n        };\n\n        component.reflash = component.refresh;\n\n        return component;\n      }; // End of renderingFunc definition\n\n    Object.defineProperty(renderingFunc, \"name\", {\n      value: `render_${tmplId}`,\n      writable: false,\n    });\n\n    if (tmplId) {\n      const tmplMeta: TemplateMeta = configs.debug\n        ? {\n          renderingFunc: renderingFunc,\n          sourceGenFunc: sourceGenFunc,\n          source: escapeHtml.escape(\n            `function ${tmplId}_source (${templateEngine.keys.dataKeyName}, ${templateEngine.keys.statusKeyName}, ${templateEngine.keys.componentKeyName}, ${templateEngine.keys.i18nKeyName}, __lazyScope, __debugger) {\\n${source}\\n}`\n          ),\n          templateText: escapeHtml.escape(templateText),\n        }\n        : {\n          renderingFunc: renderingFunc,\n          sourceGenFunc: sourceGenFunc,\n        };\n      cachedTmpl.set(tmplId, tmplMeta);\n\n      const tmplIdNames = tmplId.split(\"-\");\n      if (tmplIdNames.length > 1) {\n        const group = tmplIdNames[0];\n        let groupObj = tmpl[group];\n        if (!groupObj) {\n          tmpl[group] = groupObj = {};\n        }\n        const tmplIdSub = tmplIdNames\n          .slice(1)\n          .map((part, index) =>\n            index === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)\n          )\n          .join(\"\");\n        groupObj[tmplIdSub] = tmplMeta.renderingFunc;\n      }\n    }\n    return renderingFunc;\n  }); // End of templateBuilder\n\ncompomint.remapTmpl = function (json: Record<string, string>): void {\n  Object.keys(json).forEach(function (oldKey: string) {\n    const newKey = json[oldKey];\n    const meta = cachedTmpl.get(oldKey);\n    if (meta) {\n      cachedTmpl.set(newKey, meta);\n      if (configs.debug)\n        console.log(`Remapped template \"${oldKey}\" to \"${newKey}\"`);\n    } else if (configs.debug) {\n      console.warn(\n        `Cannot remap template: Old key \"${oldKey}\" not found in cache.`\n      );\n    }\n  });\n};\n\ncompomint.tmpl = function (tmplId: string): RenderingFunction | null {\n  const tmplMeta = cachedTmpl.get(tmplId);\n  return tmplMeta ? tmplMeta.renderingFunc : null;\n};\n\nconst safeTemplate = function (\n  source: Element | string\n): Element | TemplateElement {\n  let template: TemplateElement;\n  if (typeof source !== \"undefined\" && source instanceof Element) {\n    if (source.tagName === \"TEMPLATE\") return source as TemplateElement;\n    return source; // Assume it's a container element\n  } else if (typeof source !== \"string\") {\n    if (configs.debug)\n      console.warn(\n        \"safeTemplate received non-string/non-element source:\",\n        source\n      );\n    source = \"\";\n  }\n\n  template = document.createElement(\"template\");\n  if (isSupportTemplateTag) {\n    const encodedSource = source.replace(\n      /<(?!template|\\/template|body|\\/body|html|\\/html|head|\\/head|style|\\/style|script|\\/script|link|\\/link|meta|\\/meta|!--)/gi,\n      \"&lt;\"\n    );\n    template.innerHTML = encodedSource;\n  } else {\n    const encodedSource = source\n      .replace(\n        /<(?!template|\\/template|body|\\/body|html|\\/html|head|\\/head|style|\\/style|script|\\/script|link|\\/link|meta|\\/meta|!--)/gi,\n        \"&lt;\"\n      )\n      .replace(/<template/g, '<script type=\"template\"')\n      .replace(/<\\/template>/g, \"</script>\");\n    template.innerHTML = encodedSource;\n  }\n  return template;\n};\n\nconst addTmpl: CompomintGlobal[\"addTmpl\"] = (compomint.addTmpl = function (\n  tmplId,\n  element,\n  templateEngine\n) {\n  let templateText;\n\n  // Check for Element or SSR polyfill objects\n  if (\n    typeof element !== \"undefined\" &&\n    element &&\n    typeof element === \"object\"\n  ) {\n    // Try to get template content from SSR polyfill object or real Element\n    if (\"_innerHTML\" in element) {\n      templateText = (element as any)._innerHTML;\n    } else if (\"innerHTML\" in element) {\n      templateText = element.innerHTML;\n    } else {\n      templateText = String(element);\n    }\n  } else {\n    templateText = String(element);\n  }\n  templateText = escapeHtml.unescape(templateText.replace(/<!---|--->/gi, \"\"));\n  return templateBuilder(tmplId, templateText, templateEngine);\n});\n\nconst addTmpls: CompomintGlobal[\"addTmpls\"] = (compomint.addTmpls = function (\n  source,\n  removeInnerTemplate,\n  templateEngine\n) {\n  if (typeof removeInnerTemplate !== \"boolean\" && templateEngine == undefined) {\n    templateEngine = removeInnerTemplate as Partial<TemplateEngine> | undefined;\n    removeInnerTemplate = false;\n  } else {\n    removeInnerTemplate = !!removeInnerTemplate;\n  }\n\n  // Use default template engine if none provided\n  if (!templateEngine) {\n    templateEngine = compomint.templateEngine;\n  }\n\n  const container = safeTemplate(source);\n  const content = (container as TemplateElement).content || container; // Use content if available\n  const tmplNodes = content.querySelectorAll<Element>(\n    'template[id], script[type=\"text/template\"][id], script[type=\"text/compomint\"][id]'\n  );\n\n  tmplNodes.forEach((node) => {\n    const tmplId = node.id;\n    if (!tmplId) return;\n\n    if ((node as HTMLElement).dataset.coLoadScript !== undefined) {\n      addTmpl(tmplId, node, templateEngine)({}); // Execute immediately if data-co-load-script\n    } else {\n      addTmpl(tmplId, node, templateEngine);\n    }\n\n    if (removeInnerTemplate && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n  return container;\n});\n\nconst addTmplByUrl: CompomintGlobal[\"addTmplByUrl\"] = (compomint.addTmplByUrl =\n  function compomint_addTmplByUrl(importData, option, callback) {\n    if (!callback && typeof option === \"function\") {\n      callback = option;\n      option = {};\n    }\n\n    const defaultOptions = {\n      loadScript: true,\n      loadStyle: true,\n      loadLink: true,\n      templateEngine: undefined,\n    };\n    const mergedOptions = Object.assign(\n      {},\n      defaultOptions,\n      option as Record<string, any>\n    ); // Ensure option is object\n\n    const importDataParser = (\n      obj: string | any\n    ): { url: string; option: Record<string, any> } | null => {\n      if (typeof obj === \"string\") {\n        return { url: obj, option: mergedOptions };\n      } else if (obj && typeof obj === \"object\" && obj.url) {\n        return {\n          url: obj.url,\n          option: Object.assign({}, mergedOptions, obj.option),\n        };\n      } else {\n        console.error(\"Invalid import data format in addTmplByUrl:\", obj);\n        return null;\n      }\n    };\n\n    const appendElements = (\n      elements: NodeListOf<Element> | Element[]\n    ): void => {\n      elements.forEach((element) => {\n        if (!element) return;\n        if (element.id) {\n          const oldElement = document.getElementById(element.id);\n          if (oldElement) oldElement.parentNode?.removeChild(oldElement);\n        }\n        if (\n          element.tagName === \"SCRIPT\" ||\n          element.tagName === \"LINK\" ||\n          element.tagName === \"STYLE\"\n        ) {\n          document.head.appendChild(element);\n        } else {\n          document.body.appendChild(element);\n        }\n      });\n    };\n\n    const importFunc = (\n      source: string,\n      currentOption: Record<string, any>\n    ): void => {\n      const templateContainer = safeTemplate(source);\n      addTmpls(templateContainer, false, currentOption.templateEngine);\n      const content =\n        (templateContainer as TemplateElement).content || templateContainer;\n\n      if (currentOption.loadLink) {\n        const links = content.querySelectorAll<HTMLLinkElement>(\n          'link[rel=\"stylesheet\"]'\n        );\n        appendElements(links);\n      }\n      if (currentOption.loadStyle) {\n        const styles = content.querySelectorAll<HTMLStyleElement>(\"style[id]\");\n        appendElements(styles);\n      }\n      if (currentOption.loadScript) {\n        const scripts = content.querySelectorAll<HTMLScriptElement>(\n          'script:not([type]), script[type=\"text/javascript\"], script[type=\"module\"]'\n        );\n        const executableScripts = Array.from(scripts)\n          .filter((node) => {\n            let parent = node.parentNode;\n            while (parent) {\n              if (\n                parent.nodeName === \"TEMPLATE\" ||\n                (parent.nodeName === \"SCRIPT\" &&\n                  (parent as HTMLScriptElement).type.includes(\"template\"))\n              )\n                return false;\n              parent = parent.parentNode;\n            }\n            return true;\n          })\n          .map((node) => {\n            const scriptElm = document.createElement(\"script\");\n            node\n              .getAttributeNames()\n              .forEach((name) =>\n                scriptElm.setAttribute(name, node.getAttribute(name)!)\n              );\n            if (node.innerHTML) scriptElm.textContent = node.innerHTML;\n            return scriptElm;\n          });\n        appendElements(executableScripts);\n      }\n    };\n\n    const loadResource = (dataItem: string | any): Promise<void> => {\n      return new Promise((resolve, reject) => {\n        const parsedData = importDataParser(dataItem);\n        if (!parsedData) {\n          resolve(); // Resolve immediately for invalid data\n          return;\n        }\n        const src = parsedData.url;\n        const currentOption = parsedData.option;\n\n        if (src.endsWith(\".js\")) {\n          const script = genElement(\"script\", {\n            async: true,\n            src: src,\n          }) as HTMLScriptElement;\n          script.addEventListener(\"load\", () => resolve());\n          script.addEventListener(\"error\", () => {\n            console.error(`Failed to load script: ${src}`);\n            reject(new Error(`Failed to load script: ${src}`));\n          });\n          document.head.appendChild(script);\n        } else if (src.endsWith(\".css\")) {\n          const link = genElement(\"link\", {\n            type: \"text/css\",\n            rel: \"stylesheet\",\n            href: src,\n          }) as HTMLLinkElement;\n          link.addEventListener(\"load\", () => resolve());\n          link.addEventListener(\"error\", () => {\n            console.error(`Failed to load stylesheet: ${src}`);\n            reject(new Error(`Failed to load stylesheet: ${src}`));\n          });\n          document.head.appendChild(link);\n        } else {\n          requestFunc(src, null, (source, status) => {\n            if (status === 200 || status === 0) {\n              try {\n                importFunc(source!, currentOption); // Use non-null assertion for source\n                resolve(); // Resolve after successful processing\n              } catch (e) {\n                console.error(`Error processing imported HTML from ${src}:`, e);\n                reject(\n                  new Error(`Error processing imported HTML from ${src}: ${e}`)\n                );\n              }\n            } else {\n              console.error(\n                `Failed to fetch template file: ${src} (Status: ${status})`\n              );\n              reject(\n                new Error(\n                  `Failed to fetch template file: ${src} (Status: ${status})`\n                )\n              );\n            }\n          });\n        }\n      });\n    };\n\n    // Handle null or undefined importData\n    if (importData == null) {\n      if (callback) {\n        callback();\n        return;\n      } else {\n        return Promise.resolve();\n      }\n    }\n\n    // Create the promise for all operations\n    const operationPromise = Array.isArray(importData)\n      ? importData.length === 0\n        ? Promise.resolve()\n        : Promise.all(importData.map(loadResource))\n          .then(() => { })\n          .catch((err) => {\n            console.error(\"Error loading resources in addTmplByUrl:\", err);\n            throw err; // Re-throw the error to allow operationPromise to reject\n          })\n      : loadResource(importData).catch((err) => {\n        console.error(\"Error loading resource in addTmplByUrl:\", err);\n        throw err; // Re-throw the error to allow operationPromise to reject\n      });\n\n    // If callback is provided, use it; otherwise return the promise\n    if (callback) {\n      operationPromise\n        .then(() => callback())\n        .catch((err) => {\n          // Log error but still call callback for backward compatibility\n          console.error(\"Error in addTmplByUrl callback mode:\", err);\n          callback();\n        });\n      return;\n    } else {\n      return operationPromise;\n    }\n  });\n\nconst requestFunc = function (\n  url: string,\n  option: RequestInit | null,\n  callback: (\n    responseText: string | null,\n    status: number,\n    xhr: XMLHttpRequest\n  ) => void\n): void {\n  const xmlhttp = new XMLHttpRequest();\n\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n      if (xmlhttp.status == 200 || xmlhttp.status === 0) {\n        callback(xmlhttp.responseText, xmlhttp.status, xmlhttp);\n      } else {\n        if (xmlhttp.status == 404)\n          console.error(`Error 404: Not Found - ${url}`);\n        else if (xmlhttp.status >= 400)\n          console.error(`HTTP Error ${xmlhttp.status} for ${url}`);\n        else console.error(`Request failed for ${url}`, xmlhttp.statusText);\n        callback(null, xmlhttp.status, xmlhttp);\n      }\n    }\n  };\n\n  xmlhttp.onerror = function () {\n    console.error(`Network error requesting ${url}`);\n    callback(null, 0, xmlhttp);\n  };\n  xmlhttp.ontimeout = function () {\n    console.error(`Request timed out for ${url}`);\n    callback(null, 408, xmlhttp);\n  };\n\n  try {\n    const method = (option && option.method) || \"GET\";\n    xmlhttp.open(method, url, true);\n\n    if (option) {\n      if ((option as any).timeout) xmlhttp.timeout = (option as any).timeout;\n      const headers = option.headers as Record<string, string>;\n      if (headers) {\n        Object.keys(headers).forEach((key) => {\n          xmlhttp.setRequestHeader(key, headers[key]);\n        });\n      }\n      xmlhttp.send((option.body as any) || null);\n    } else {\n      xmlhttp.send();\n    }\n  } catch (e: any) {\n    console.error(`Error sending request to ${url}:`, e);\n    callback(null, 0, xmlhttp);\n  }\n};\n\ncompomint.i18n = {};\n\ncompomint.addI18n = function (\n  fullKey: string,\n  i18nObj: Record<string, any>\n): void {\n  if (\n    !fullKey ||\n    typeof fullKey !== \"string\" ||\n    !i18nObj ||\n    typeof i18nObj !== \"object\"\n  ) {\n    console.error(\"Invalid arguments for addI18n:\", fullKey, i18nObj);\n    return;\n  }\n\n  const langKeyNames = fullKey.split(\".\");\n  let target: any = compomint.i18n;\n  const keyLength = langKeyNames.length - 1;\n\n  langKeyNames.forEach(function (key: string, i: number) {\n    if (!key) return;\n\n    if (keyLength === i) {\n      // Check if any language value is an array\n      const hasArrayValues = Object.keys(i18nObj).some((lang) =>\n        Array.isArray(i18nObj[lang])\n      );\n\n      if (hasArrayValues) {\n        // Handle arrays - create array structure\n        if (!target[key]) {\n          target[key] = [];\n        }\n\n        // Process each language's array\n        Object.keys(i18nObj)\n          .filter((lang) => Array.isArray(i18nObj[lang]))\n          .forEach((lang) => {\n            const array = i18nObj[lang];\n            array.forEach((item: any, index: number) => {\n              if (!target[key][index]) {\n                target[key][index] = {};\n              }\n              if (item instanceof Object && !Array.isArray(item)) {\n                Object.keys(item).forEach((subKey) => {\n                  compomint.addI18n(\n                    fullKey + \".\" + index + \".\" + subKey,\n                    item[subKey]\n                  );\n                });\n              }\n            });\n          });\n      } else {\n        // Handle regular i18n function\n        if (!target[key]) {\n          target[key] = function (defaultText?: string): string {\n            const lang = document.documentElement.lang || \"en\";\n            let label = i18nObj[lang];\n            if (label === undefined || label === null) {\n              label = defaultText;\n              if (configs.debug)\n                console.warn(\n                  `i18n: Label key [\"${fullKey}\"] for lang \"${lang}\" is missing. Using default: \"${defaultText}\"`\n                );\n            }\n            return label !== undefined && label !== null ? String(label) : \"\";\n          };\n        }\n        // Handle nested objects within the language definitions\n        Object.keys(i18nObj)\n          .filter(\n            (lang) =>\n              i18nObj[lang] instanceof Object && !Array.isArray(i18nObj[lang])\n          ) // Check for plain objects\n          .forEach((subKey) => {\n            compomint.addI18n(fullKey + \".\" + subKey, i18nObj[subKey]);\n            // delete i18nObj[subKey]; // Avoid deleting if it's also a language key\n          });\n      }\n    } else {\n      if (!target[key] || typeof target[key] === \"function\") {\n        target[key] = {};\n      }\n      target = target[key];\n    }\n  });\n};\n\ncompomint.addI18ns = function (i18nObjs: Record<string, any>): void {\n  // Cache for target path resolution to avoid repeated splits\n  const targetCache = new Map<string, any>();\n\n  function getTargetPath(fullKey: string): any {\n    if (targetCache.has(fullKey)) {\n      return targetCache.get(fullKey);\n    }\n\n    const keyParts = fullKey.split(\".\");\n    let target = compomint.i18n;\n    for (let i = 0; i < keyParts.length - 1; i++) {\n      if (!target[keyParts[i]]) {\n        target[keyParts[i]] = {};\n      }\n      target = target[keyParts[i]];\n    }\n\n    targetCache.set(fullKey, target);\n    return target;\n  }\n\n  function isTranslationObject(value: any): boolean {\n    // Fast check: if it has nested objects, it's not a translation\n    for (const key in value) {\n      const val = value[key];\n      const type = typeof val;\n      if (type !== \"string\" && type !== \"number\" && type !== \"boolean\") {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function processNested(obj: any, keyPath: string = \"\"): void {\n    for (const key in obj) {\n      const value = obj[key];\n      const fullKey = keyPath ? keyPath + \".\" + key : key;\n\n      if (Array.isArray(value)) {\n        // Handle array at this level - optimized version\n        const target = getTargetPath(fullKey);\n        const finalKey = fullKey.split(\".\").pop()!;\n\n        if (!target[finalKey]) {\n          target[finalKey] = [];\n        }\n\n        // Process each array item with reduced function calls\n        for (let index = 0; index < value.length; index++) {\n          const item = value[index];\n          if (!target[finalKey][index]) {\n            target[finalKey][index] = {};\n          }\n\n          if (item && typeof item === \"object\") {\n            // Direct processing without recursive addI18n calls\n            for (const itemKey in item) {\n              const itemValue = item[itemKey];\n              if (itemValue && typeof itemValue === \"object\") {\n                // Create the i18n function directly\n                const itemPath = fullKey + \".\" + index + \".\" + itemKey;\n                compomint.addI18n(itemPath, itemValue);\n              }\n            }\n          }\n        }\n      } else if (value && typeof value === \"object\") {\n        if (isTranslationObject(value)) {\n          // This is a translation object, use addI18n\n          compomint.addI18n(fullKey, value);\n        } else {\n          // This is a nested structure, continue processing\n          processNested(value, fullKey);\n        }\n      } else {\n        // Primitive value, use addI18n\n        compomint.addI18n(fullKey, value);\n      }\n    }\n  }\n\n  processNested(i18nObjs);\n};\n\nlet elementCount = 0;\ntools.genId = function (tmplId: string): string {\n  elementCount++;\n  return tmplId + elementCount;\n};\n\nconst applyElementProps = (tools.applyElementProps = function (\n  element: HTMLElement,\n  attrs: Record<string, any>\n): Element {\n  Object.keys(attrs).forEach(function (key) {\n    const value = attrs[key];\n    const propName = key === \"class\" ? \"className\" : key;\n\n    try {\n      if (key === \"style\" && typeof value === \"object\" && value !== null) {\n        Object.assign(element.style, value); // Assign style object\n      } else if (\n        key === \"dataset\" &&\n        typeof value === \"object\" &&\n        value !== null\n      ) {\n        Object.assign((element as HTMLElement).dataset, value); // Assign dataset object\n      } else if (key.startsWith(\"on\") && typeof value === \"function\") {\n        // Directly assign event handlers like onclick, onmouseover\n        (element as any)[key.toLowerCase()] = value;\n      } else if (propName in element) {\n        (element as any)[propName] = value;\n      } else {\n        element.setAttribute(key, String(value));\n      }\n    } catch (e: any) {\n      console.error(\n        `Error setting attribute/property \"${key}\" on <${element.tagName}>:`,\n        e\n      );\n    }\n  });\n  return element;\n});\n\nconst genElement = (tools.genElement = function (\n  tagName: string,\n  attrs: Record<string, any> | string | Node | (string | Node)[] = {},\n  ...children: (string | Node)[]\n): Element {\n  const element = document.createElement(tagName);\n  let actualAttrs: Record<string, any> = {};\n\n  if (typeof attrs === \"string\") {\n    children.unshift(attrs); // Prepend string as first child\n  } else if (attrs instanceof Node) {\n    children.unshift(attrs); // Prepend Node as first child\n  } else if (Array.isArray(attrs)) {\n    children = attrs.concat(children); // Concatenate arrays\n  } else {\n    actualAttrs = attrs; // It's an attributes object\n  }\n\n  // Set attributes/properties\n  applyElementProps(element, actualAttrs);\n\n  // Append children\n  children.forEach((child) => {\n    if (typeof child === \"string\") {\n      element.appendChild(document.createTextNode(child));\n    } else if (child instanceof Node) {\n      element.appendChild(child);\n    }\n  });\n  return element;\n});\n\ntools.props = function (...propsObjects: Record<string, any>[]): string {\n  if (!propsObjects || propsObjects.length === 0) return \"\";\n  const mergedProps = Object.assign({}, ...propsObjects);\n  const propStrArray: string[] = [];\n  Object.keys(mergedProps).forEach(function (key) {\n    const value = mergedProps[key];\n    if (value || value === 0) {\n      const escapedValue = String(value).replace(/\"/g, \"&quot;\");\n      propStrArray.push(`${key}=\"${escapedValue}\"`);\n    }\n  });\n  return propStrArray.join(\" \");\n};\n\n// Add SSR functionality\ncompomint.ssr = {\n  isSupported: Environment.isServer,\n  setupEnvironment: setupSSREnvironment,\n  createRenderer: (options = {}) => createSSRRenderer(compomint, options),\n  renderToString: async (templateId: string, data: any = {}, options = {}) => {\n    const renderer = createSSRRenderer(compomint, options);\n    const result = await renderer.renderToString(templateId, data, options);\n    return result.html;\n  },\n  renderPage: async (templateId: string, data: any = {}, pageOptions = {}) => {\n    const renderer = createSSRRenderer(compomint);\n    return await renderer.renderPage(templateId, data, pageOptions);\n  },\n};\n\n// Setup SSR environment if we're on the server\nif (Environment.isServer()) {\n  setupSSREnvironment();\n}\n\ncompomint.hydrate = function (): void {\n  if (Environment.isServer()) {\n    console.warn(\"Hydration cannot be run on the server.\");\n    return;\n  }\n\n  const ssrData = (window as any).__COMPOMINT_SSR__;\n  if (!ssrData) {\n    if (configs.debug) {\n      console.log(\"No SSR data found for hydration.\");\n    }\n    return;\n  }\n\n  if (configs.debug) {\n    console.log(\"Starting Compomint hydration...\", ssrData);\n  }\n\n  const { componentIds, initialStates } = ssrData;\n\n  componentIds.forEach((componentId: string) => {\n    const element = document.querySelector(\n      `[data-co-id=\"${componentId}\"]`\n    ) as HTMLElement;\n    if (!element) {\n      if (configs.debug) {\n        console.warn(\n          `Element for component ID \"${componentId}\" not found for hydration.`\n        );\n      }\n      return;\n    }\n\n    const tmplId = element.dataset.coTmplId || componentId.split(\"_\")[0];\n    const tmplFunc = compomint.tmpl(tmplId);\n\n    if (tmplFunc) {\n      const initialState = initialStates ? initialStates[componentId] : {};\n      const data = initialState ? initialState.data : {};\n      const status = initialState ? initialState.status : {};\n\n      const component = tmplFunc({\n        ...initialState.data,\n        ...data,\n        //$existingElement: element,\n        $baseComponent: { status: initialState.status, _id: componentId },\n      });\n\n      const newElement = component.element;\n      newElement.dataset.coId = componentId;\n      newElement.dataset.coTmplId = tmplId;\n      (newElement as any).__compomint_scope__ = component;\n\n      element.parentElement?.replaceChild(newElement, element);\n\n      if (configs.debug) {\n        console.log(\n          `Hydrated component \"${componentId}\" from template \"${tmplId}\".`\n        );\n      }\n    } else {\n      if (configs.debug) {\n        console.warn(\n          `Template function for \"${tmplId}\" not found during hydration.`\n        );\n      }\n    }\n  });\n\n  // Clean up SSR data\n  delete (window as any).__COMPOMINT_SSR__;\n};\n\n// Add built-in template\napplyBuiltInTemplates(addTmpl);\n\nexport { compomint, tmpl };\n","import { CompomintConfigs, CompomintGlobal, TemplateEngine } from \"./type\";\nimport { defaultTemplateEngine } from \"./default-template-engine\";\n\n//\n// SSR template settings (deep clone of default engine without style rule)\n//\nconst defaultTemplateEngineSSR = (\n  compomint: CompomintGlobal\n): TemplateEngine => {\n  // Get the default template engine\n  const baseEngine = defaultTemplateEngine(compomint);\n\n  // Create a deep clone by manually copying all properties except style rule\n  const ssrEngine: TemplateEngine = {\n    rules: {},\n    keys: { ...baseEngine.keys }\n  };\n\n  // Copy all rules except style and element for SSR (DOM manipulation not available)\n  // We need to ensure 'element' rule comes BEFORE 'evaluate' rule because 'evaluate' matches ##...## greedily\n  Object.keys(baseEngine.rules).forEach((ruleKey) => {\n    if (ruleKey === 'evaluate') {\n      // Add element rule before evaluate\n      ssrEngine.rules.element = {\n        pattern: /##%([\\s\\S]+?)##/g,\n        exec: function (target: string): string {\n          return \"';\\n__p+='<!-- SSR: Element insertion not supported -->';\\n__p+='\";\n        }\n      };\n    }\n\n    if (ruleKey !== 'style' && ruleKey !== 'element') {\n      ssrEngine.rules[ruleKey] = { ...baseEngine.rules[ruleKey] };\n    }\n  });\n\n  // If element rule wasn't added (e.g. evaluate missing), add it now\n  if (!ssrEngine.rules.element) {\n    ssrEngine.rules.element = {\n      pattern: /##%([\\s\\S]+?)##/g,\n      exec: function (target: string): string {\n        return \"';\\n__p+='<!-- SSR: Element insertion not supported -->';\\n__p+='\";\n      }\n    };\n  }\n\n  return ssrEngine;\n};\n\nexport { defaultTemplateEngineSSR };\n","import { CompomintGlobal } from \"./type\";\n\nconst applyBuiltInTemplates = (addTmpl: CompomintGlobal[\"addTmpl\"]): void => {\n  // co-Ele is a shorthand for co-Element, it will generate a div element with the given props and event\n  addTmpl(\n    \"co-Ele\",\n    `<##=data[0]##></##=data[0]##>###compomint.tools.applyElementProps(this, data[1]);##`\n  );\n  addTmpl(\n    \"co-Element\",\n    `##\n  data.tag = data.tag || 'div';\n  ##\n  &lt;##=data.tag##\n    ##=data.id ? 'id=\"' + (data.id === true ? component._id : data.id) + '\"' : ''##\n    data-co-props=\"##:data.props##\"\n    data-co-event=\"##:data.event##\"&gt;\n    ##if (typeof data.content === \"string\") {##\n    ##=data.content##\n    ##} else {##\n      ##%data.content##\n    ##}##\n  &lt;/##=data.tag##&gt;`\n  );\n};\n\nexport { applyBuiltInTemplates };\n"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","SuppressedError","firstElementChild","ele","children","childNodes","i","size","length","Element","childElementCount","Array","prototype","filter","call","child","cleanNode","node","n","nodeType","test","nodeValue","removeChild","stringToElement","str","isNaN","Number","document","createTextNode","String","domParser","DOMParser","parseFromString","type","body","firstChild","appendChild","fragment","createDocumentFragment","defaultTemplateEngine","compomint","configs","rules","style","pattern","exec","dumy","createElement","innerHTML","styleNode","content","querySelector","id","oldStyleNode","getElementById","_a","parentNode","head","commentArea","preEvaluate","tmplId","Function","throwError","console","error","name","message","warn","interpolate","escape","elementProps","props","lazyExec","data","lazyScope","component","wrapper","elementPropsArray","forEach","eventId","$elementTrigger","dataset","coProps","Object","keys","key","setAttribute","namedElement","namedElementArray","coNamedElement","debug","elementRef","elementRefArray","func","coElementRef","elementLoad","elementLoadSplitArray","split","elementLoadArray","coLoad","loadFunc","loadFuncParams","element","customData","event","eventStrArray","source","eventArray","eventSplitArray","push","join","self","this","attacher","selectedArray","coEvent","selected","eventFunc","isArray","trigger","target","eventName","customEvent","Event","bubbles","cancelable","dispatchEvent","eventData","$childTarget","$targetElement","eventFuncParams","componentElement","parentElement","eventListener","stopPropagation","addEventListener","toString","eventMap","triggerName","eventType","selectedEventFunc","elementSplitArray","elementArray","elementId","childTarget","nonblocking","$tmplElement","doFunc","docFragment","childElement","nodeToAppend","Node","beforeAppendTo","replaceChild","afterAppendTo","setTimeout","childScope","parentComponent","removeError","undefined","lazyEvaluate","lazyEvaluateArray","selectedFunc","idx","evaluate","escapeSyntax","syntax","dataKeyName","statusKeyName","componentKeyName","i18nKeyName","_originalWindow","window","Environment","isServer","globalThis","__SSR_ENVIRONMENT__","process","versions","isBrowser","hasDOM","isNode","SSRDOMPolyfill","constructor","elements","Map","styleCollector","scriptCollector","getInstance","instance","tagName","toUpperCase","className","textContent","_innerHTML","attributes","lastChild","set","html","parseAndCreateChildren","templateRegex","scriptRegex","scriptCompomintRegex","match","lastIndex","templateElement","createTemplateElement","scriptElement","createScriptElement","template","unescapedContent","replace","script","getAttribute","get","index","indexOf","splice","normalize","selector","startsWith","substring","findById","findByClass","findByTagName","querySelectorAll","results","selectors","map","s","trim","sel","matches","includes","childResults","trimmedSelector","tagMatch","expectedTag","toLowerCase","attrMatches","attrMatch","attrContent","slice","parts","attrName","attrValue","found","toHTML","defineProperty","configurable","enumerable","text","createComment","collectStyle","css","collectScript","getCollectedStyles","getCollectedScripts","reset","setupSSREnvironment","ssrDocument","polyfill","contains","documentElement","lang","createSSRDocument","ssrWindow","CharacterData","DocumentType","XMLHttpRequest","Error","global","SSRRenderer","options","renderStartTime","assign","renderToString","hydrateOnClient","generateIds","preserveWhitespace","setupEnvironment","setupSSROverrides","originalDocument","templateId_1","arguments","templateId","Date","now","mergedOptions","doc","templateMeta","tmplCache","sourceGenFunc","ssrData","$ssr","$generateIds","$hydrateOnClient","i18n","tmpl","extractStylesAndScripts","templateText","extractStylesFromTemplateText","scripts","componentId","tools","genId","metadata","templateIds","componentIds","renderTime","renderMultiple","templates_1","templates","r","Boolean","reduce","acc","concat","renderPage","pageOptions","title","meta","links","bodyClass","escapeHTML","m","property","link","src","generateHydrationScript","renderComponentSSR","templateFunction","mockContainer","extractHTML","from","hydrationData","JSON","stringify","escapeMap","char","decodedText","styleRegex","styleMatch","getStats","environment","polyfillActive","lastRenderTime","createSSRRenderer","params","TypeError","to","nextSource","nextKey","hasOwnProperty","writable","item","printExecTime","cachedTmpl","has","Set","isSupportTemplateTag","noMatch","escapes","escaper","templateEngine","baseEngine","ssrEngine","ruleKey","defaultTemplateEngineSSR","escapeHtml","unescapeMap","createEscaper","testRegexp","RegExp","replaceRegexp","string","unescape","matcherFunc","templateRules","patternArray","execArray","lazyExecMap","lazyScopeSeed","templateRule","arrayKey","lazyExecKeys","escapeFunc","defaultMatcher","templateBuilder","customTemplateEngine","matcher","time","offset","selectedMatchContent","matchIndex","some","timeEnd","templateParser","renderingFunc","wrapperElement","callback","baseComponent","existingElement","firstArg","$wrapperElement","$callback","$baseComponent","$existingElement","parse","status","newComponent","remove","spacer","beforeRemove","selectedEvent","removeEventListener","parent","removedElement","afterRemove","appendTo","release","render","newData","refresh","reflashData","reflash","_id","hasParent","temp","returnTarget","renderedHTML","host","shadow","attachShadow","mode","$props","prop","camelCased","g","liveReloadSupport","getOwnPropertyNames","keepProps","currentComponent","targetElement","tmplFunc","hooks","beforeRefresh","afterRefresh","currentData","tmplMeta","tmplIdNames","group","groupObj","part","charAt","remapTmpl","json","oldKey","newKey","log","safeTemplate","encodedSource","addTmpl","addTmpls","removeInnerTemplate","container","coLoadScript","addTmplByUrl","importData","option","defaultOptions","loadScript","loadStyle","loadLink","appendElements","oldElement","loadResource","dataItem","parsedData","obj","url","currentOption","endsWith","genElement","async","rel","href","requestFunc","templateContainer","styles","executableScripts","nodeName","scriptElm","getAttributeNames","importFunc","operationPromise","all","catch","err","xmlhttp","onreadystatechange","readyState","DONE","responseText","statusText","onerror","ontimeout","method","open","timeout","headers","setRequestHeader","send","addI18n","fullKey","i18nObj","langKeyNames","keyLength","subKey","defaultText","label","addI18ns","i18nObjs","targetCache","getTargetPath","keyParts","isTranslationObject","processNested","keyPath","finalKey","pop","itemKey","itemValue","itemPath","elementCount","applyElementProps","attrs","propName","actualAttrs","unshift","propsObjects","mergedProps","propStrArray","escapedValue","ssr","isSupported","createRenderer","args_1","renderer","hydrate","__COMPOMINT_SSR__","initialStates","coTmplId","initialState","newElement","coId","__compomint_scope__","applyBuiltInTemplates"],"mappings":"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"}