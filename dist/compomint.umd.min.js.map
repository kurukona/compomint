{"version":3,"file":"compomint.umd.min.js","sources":["../src/utils.ts","../src/compomint.ts","../src/default-template-engine.ts","../src/built-in-templates.ts"],"sourcesContent":["\nconst firstElementChild = function (ele: Element | DocumentFragment): Element | null {\n  if (ele.firstElementChild) return ele.firstElementChild;\n  const children = ele.childNodes;\n  for (let i = 0, size = children.length; i < size; i++) {\n    if (children[i] instanceof Element) {\n      return children[i] as Element;\n    }\n  }\n  return null;\n};\n\nconst childNodeCount = function (ele: Element | DocumentFragment): number {\n  return (\n    ele.childElementCount ||\n    Array.prototype.filter.call(ele.childNodes, function (child: Node) {\n      return child instanceof Node;\n    }).length\n  );\n};\n\nconst childElementCount = function (ele: Element | DocumentFragment): number {\n  return (\n    ele.childElementCount ||\n    Array.prototype.filter.call(ele.childNodes, function (child: Node) {\n      return child instanceof Element;\n    }).length\n  );\n};\n\nconst cleanNode = function (node: Node): void {\n  for (let n = 0; n < node.childNodes.length; n++) {\n    const child = node.childNodes[n];\n    if (\n      child.nodeType === 8 || // Comment node\n      (child.nodeType === 3 && !/\\S/.test(child.nodeValue || '')) // Text node with only whitespace\n    ) {\n      node.removeChild(child);\n      n--; // Adjust index after removal\n    } else if (child.nodeType === 1) {\n      // Element node\n      cleanNode(child); // Recurse\n    }\n  }\n};\n\nconst domParser = new DOMParser();\nconst stringToElement = function (str: string | number): Node {\n  if (typeof str === 'number' || !isNaN(Number(str))) {\n    return document.createTextNode(String(str));\n  } else if (typeof str === 'string') {\n    try {\n      const doc = domParser.parseFromString(str, \"text/html\");\n      const body = doc.body;\n      if (body.childNodes.length === 1) {\n        return body.firstChild!;\n      } else {\n        const fragment = document.createDocumentFragment();\n        while (body.firstChild) {\n          fragment.appendChild(body.firstChild);\n        }\n        return fragment;\n      }\n    } catch (e) {\n      return document.createTextNode(str);\n    }\n  } else {\n    return document.createTextNode('');\n  }\n};\n\nconst isPlainObject = function (value: unknown) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport {\n  firstElementChild,\n  childNodeCount,\n  childElementCount,\n  cleanNode,\n  stringToElement,\n  isPlainObject,\n};\n","/*\n * Copyright (c) 2025-present, Choi Sungho\n * Code released under the MIT license\n */\n\nimport {\n  CompomintGlobal,\n  ComponentScope,\n  LazyScope,\n  RenderingFunction,\n  TemplateEngine,\n  TemplateMeta,\n  TemplateRule,\n  Tools,\n  TemplateElement,\n  CompomintConfigs,\n} from \"./type\";\nimport { defaultTemplateEngine } from \"./default-template-engine\";\nimport { applyBuiltInTemplates } from \"./built-in-templates\";\nimport { firstElementChild, childElementCount, cleanNode } from \"./utils\";\n\n// Polyfill for Object.assign\nif (typeof Object.assign != \"function\") {\n  Object.defineProperty(Object, \"assign\", {\n    value: function assign(target: any, ...params: any[]) {\n      if (target == null) {\n        throw new TypeError(\"Cannot convert undefined or null to object\");\n      }\n      const to = Object(target);\n      for (let index = 0, length = params.length; index < length; index++) {\n        const nextSource = params[index];\n        if (nextSource != null) {\n          for (let nextKey in nextSource) {\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    },\n    writable: true,\n    configurable: true,\n  });\n}\n\n// Polyfill for ChildNode.remove\n(function (arr: any[]) {\n  arr.forEach(function (item) {\n    if (!item || item.hasOwnProperty(\"remove\")) {\n      return;\n    }\n    Object.defineProperty(item, \"remove\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: function remove() {\n        if (this.parentNode !== null) {\n          this.parentNode.removeChild(this);\n        }\n      },\n    });\n  });\n})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);\n\n// Polyfill for Node.isConnected\n(function (supported: boolean) {\n  if (supported) return;\n  Object.defineProperty(window.Node.prototype, \"isConnected\", {\n    get: function (): boolean {\n      return document.body.contains(this);\n    },\n  });\n})(\"isConnected\" in window.Node.prototype);\n\nconst compomint = {} as CompomintGlobal;\nconst tmpl = {} as Record<string, any>;\nconst tools = (compomint.tools = compomint.tools || ({} as Tools));\nconst configs: CompomintConfigs = (compomint.configs = Object.assign(\n  { printExecTime: false, debug: false, throwError: true },\n  compomint.configs\n));\nconst cachedTmpl = (compomint.tmplCache =\n  compomint.tmplCache || new Map<string, TemplateMeta>());\nif (!cachedTmpl.has(\"anonymous\")) {\n  cachedTmpl.set(\"anonymous\", { elements: new Set() } as TemplateMeta); // Cast to TemplateMeta\n}\nconst isSupportTemplateTag = \"content\" in document.createElement(\"template\");\n\nconst noMatch = /(.)^/;\nconst escapes: Record<string, string> = {\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\",\n  \"\\r\": \"\\\\r\",\n  \"\\n\": \"\\\\n\",\n  \"\\t\": \"\\\\t\",\n  \"\\u2028\": \"\\u2028\",\n  \"\\u2029\": \"\\u2029\",\n  \"><\": \"><\",\n  \"<\": \"<\",\n  \">\": \">\",\n};\n\nconst escaper = /\\>( |\\n)+\\<|\\>( |\\n)+|( |\\n)+\\<|\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n// set default template config\ncompomint.templateEngine = defaultTemplateEngine(configs, compomint);\n\nconst escapeHtml = (function () {\n  const escapeMap: Record<string, string> = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\", // Use HTML entity for single quote\n    \"`\": \"&#x60;\", // Use HTML entity for backtick\n    //\"\\n\": \"&#10;\", // Keep newline escaping if needed, otherwise remove\n  };\n\n  const unescapeMap: Record<string, string> = Object.keys(escapeMap).reduce(\n    (acc: Record<string, string>, key: string) => {\n      acc[escapeMap[key]] = key;\n      return acc;\n    },\n    {} as Record<string, string>\n  );\n\n  const createEscaper = function (\n    map: Record<string, string>\n  ): (str: string) => string {\n    const escaper = function (match: string): string {\n      return map[match];\n    };\n    const source = `(?:${Object.keys(map).join(\"|\").replace(/\\\\/g, \"\\\\\\\\\")})`; // Escape backslashes if any keys have them\n    const testRegexp = RegExp(source);\n    const replaceRegexp = RegExp(source, \"g\");\n    return function (string: string | null | undefined): string {\n      string = string == null ? \"\" : `${string}`;\n      return testRegexp.test(string)\n        ? string.replace(replaceRegexp, escaper)\n        : string;\n    };\n  };\n\n  return {\n    escape: createEscaper(escapeMap),\n    unescape: createEscaper(unescapeMap),\n  };\n})();\ntools.escapeHtml = escapeHtml;\n\nconst matcherFunc = function (templateRules: Record<string, TemplateRule>): {\n  templateRules: Record<string, TemplateRule>;\n  pattern: RegExp;\n  exec: ((...args: any[]) => string)[];\n  lazyExecKeys: string[];\n  lazyExec: Record<\n    string,\n    (\n      data: Record<string, any>,\n      lazyScope: LazyScope,\n      component: ComponentScope,\n      wrapper: DocumentFragment | Element\n    ) => void\n  >;\n  lazyScopeSeed: string;\n} {\n  const patternArray: string[] = [];\n  const execArray: ((...args: any[]) => string)[] = [];\n  const lazyExecMap: Record<\n    string,\n    (\n      data: Record<string, any>,\n      lazyScope: LazyScope,\n      component: ComponentScope,\n      wrapper: DocumentFragment | Element\n    ) => void\n  > = {};\n  const lazyScopeSeed: Record<string, any[]> = {};\n\n  Object.keys(templateRules).forEach(function (key) {\n    const templateRule = templateRules[key] as TemplateRule | any; // Type assertion\n    if (\n      templateRule &&\n      typeof templateRule === \"object\" &&\n      templateRule.pattern instanceof RegExp &&\n      typeof templateRule.exec === \"function\"\n    ) {\n      patternArray.push((templateRule.pattern || noMatch).source);\n      execArray.push(templateRule.exec);\n    }\n    if (\n      templateRule &&\n      typeof templateRule === \"object\" &&\n      typeof templateRule.lazyExec === \"function\"\n    ) {\n      const arrayKey = `${key}Array`;\n      lazyExecMap[arrayKey] = templateRule.lazyExec;\n      lazyScopeSeed[arrayKey] = [];\n    }\n  });\n  return {\n    templateRules: templateRules,\n    pattern: new RegExp(patternArray.join(\"|\"), \"g\"),\n    exec: execArray,\n    lazyExecKeys: Object.keys(lazyScopeSeed),\n    lazyExec: lazyExecMap,\n    lazyScopeSeed: JSON.stringify(lazyScopeSeed),\n  };\n};\n\nconst escapeFunc = function (match: string): string {\n  return escapes[match] || escapes[match.replace(/[ \\n]/g, \"\")] || \"\";\n};\n\nconst defaultMatcher = matcherFunc(compomint.templateEngine.rules);\n\nconst templateParser = function (\n  tmplId: string,\n  text: string,\n  matcher: ReturnType<typeof matcherFunc>\n): string {\n  if (configs.printExecTime) console.time(`tmpl: ${tmplId}`);\n\n  let index = 0;\n  let source = \"\";\n\n  text.replace(matcher.pattern, function (...params: any[]): string {\n    const match: string = params[0];\n    const offset: number = params[params.length - 2];\n\n    source += text.slice(index, offset).replace(escaper, escapeFunc);\n\n    let selectedMatchContent: string | undefined;\n    let matchIndex: number | null = null;\n\n    params.slice(1, -2).some(function (value: any, idx: number) {\n      if (value !== undefined) {\n        selectedMatchContent = value;\n        matchIndex = idx;\n        return true;\n      }\n      return false;\n    });\n\n    if (selectedMatchContent !== undefined && matchIndex !== null) {\n      try {\n        source += matcher.exec[matchIndex].call(\n          matcher.templateRules,\n          selectedMatchContent,\n          tmplId\n        );\n      } catch (e: any) {\n        console.error(\n          `Error executing template rule index ${matchIndex} for match \"${selectedMatchContent}\" in template \"${tmplId}\":`,\n          e\n        );\n        if (configs.throwError) throw e;\n        source += \"\";\n      }\n    } else {\n      source += match.replace(escaper, escapeFunc);\n    }\n\n    index = offset + match.length;\n    return match;\n  });\n\n  source += text.slice(index).replace(escaper, escapeFunc);\n\n  if (configs.printExecTime) console.timeEnd(`tmpl: ${tmplId}`);\n  return source;\n};\n\nconst templateBuilder = (compomint.template =\n  function compomint_templateBuilder(\n    tmplId: string,\n    templateText: string,\n    customTemplateEngine?: Partial<TemplateEngine>\n  ): RenderingFunction {\n    let templateEngine = compomint.templateEngine;\n    let matcher = defaultMatcher;\n\n    if (customTemplateEngine) {\n      templateEngine = {\n        rules: Object.assign(\n          {},\n          templateEngine.rules,\n          customTemplateEngine.rules || {}\n        ),\n        keys: Object.assign(\n          {},\n          templateEngine.keys,\n          customTemplateEngine.keys || {}\n        ),\n      };\n      matcher = matcherFunc(templateEngine.rules);\n    }\n\n    const source = `\n/* tmplId: ${tmplId} */\n//# sourceURL=http://tmpl//${tmplId.split(\"-\").join(\"//\")}.js\n// if (__debugger) {\n// debugger;\n// }\nlet __p='';\n__p+='${templateParser(tmplId, templateText, matcher)}';\nreturn __p;`;\n\n    let sourceGenFunc: Function | null = null;\n\n    try {\n      sourceGenFunc = new Function(\n        templateEngine.keys.dataKeyName as string,\n        templateEngine.keys.statusKeyName as string,\n        templateEngine.keys.componentKeyName as string,\n        templateEngine.keys.i18nKeyName as string,\n        \"compomint\",\n        \"tmpl\",\n        \"__lazyScope\",\n        \"__debugger\",\n        source\n      );\n    } catch (e: any) {\n      if (configs.throwError) {\n        console.error(\n          `Template compilation error in \"${tmplId}\", ${e.name}: ${e.message}`\n        );\n        try {\n          // Attempt re-run for potential browser debugging\n          new Function(\n            templateEngine.keys.dataKeyName as string,\n            templateEngine.keys.statusKeyName as string,\n            templateEngine.keys.componentKeyName as string,\n            templateEngine.keys.i18nKeyName as string,\n            \"compomint\",\n            \"tmpl\",\n            \"__lazyScope\",\n            \"__debugger\",\n            source\n          );\n        } catch {\n          /* Ignore re-run error */\n        }\n        throw e;\n      } else {\n        return () => ({} as ComponentScope); // Return a dummy function if not throwing\n      }\n    }\n\n    const renderingFunc: RenderingFunction =\n      function compomint_renderingFuncBuilder(...params): ComponentScope {\n        let data: Record<string, any>;\n        let wrapperElement: Element | undefined;\n        let callback: ((component: ComponentScope) => void) | undefined;\n        let baseComponent: Partial<ComponentScope> | undefined;\n\n        // Argument parsing logic\n        const firstArg = params[0];\n        if (\n          firstArg &&\n          typeof firstArg === \"object\" &&\n          (firstArg.$wrapperElement ||\n            firstArg.$callback ||\n            firstArg.$baseComponent)\n        ) {\n          data = { ...firstArg }; // Clone data object\n          wrapperElement = data.$wrapperElement;\n          delete data.$wrapperElement;\n          callback = data.$callback;\n          delete data.$callback;\n          baseComponent = data.$baseComponent;\n          delete data.$baseComponent;\n        } else {\n          data = firstArg;\n          if (typeof params[1] === \"function\") {\n            wrapperElement = undefined;\n            callback = params[1] as (component: ComponentScope) => void;\n            baseComponent = params[2];\n          } else {\n            wrapperElement = params[1];\n            callback = params[2];\n            baseComponent = params[3];\n          }\n        }\n\n        const dataKeyName = templateEngine.keys.dataKeyName as string;\n        const statusKeyName = templateEngine.keys.statusKeyName as string;\n        const lazyScope: LazyScope = JSON.parse(matcher.lazyScopeSeed);\n\n        const component: ComponentScope = Object.assign(baseComponent || {}, {\n          tmplId: tmplId,\n          element: null as any, // Initialize element\n          status: (baseComponent && baseComponent.status) || {}, // Ensure status exists\n          replace: function (newComponent: ComponentScope | Element): void {\n            const self = this as ComponentScope;\n            if (\n              !self.element ||\n              !(self.element instanceof Node) ||\n              !self.element.parentElement\n            ) {\n              if (configs.debug)\n                console.warn(\n                  `Cannot replace template \"${tmplId}\": element not in DOM.`\n                );\n              return;\n            }\n            self.element.parentElement.replaceChild(\n              (newComponent as ComponentScope).element ||\n                (newComponent as Element),\n              self.element as Node\n            );\n          },\n          remove: function (\n            spacer: boolean = false\n          ): Element | TemplateElement | Comment | DocumentFragment {\n            const self = this as ComponentScope;\n            if (self.beforeRemove) {\n              try {\n                self.beforeRemove();\n              } catch (e) {\n                console.error(\"Error in beforeRemove:\", e);\n              }\n            }\n\n            // Remote event event listener\n            // Iterate through all event handlers stored in lazyScope.eventArray\n            if (lazyScope.eventArray) {\n              lazyScope.eventArray.forEach(function (event) {\n                // For each event entry, iterate through its associated event listeners\n                event.forEach(function (selectedEvent: Record<string, any>) {\n                  if (selectedEvent.element) {\n                    if (typeof selectedEvent.eventFunc === \"function\") {\n                      selectedEvent.element.removeEventListener(\n                        \"click\",\n                        selectedEvent.eventFunc as EventListenerOrEventListenerObject\n                      ); // Remove click event listener\n                    } else {\n                      Object.keys(selectedEvent.eventFunc).forEach(function (\n                        eventType\n                      ) {\n                        selectedEvent.element.removeEventListener(\n                          eventType,\n                          (\n                            selectedEvent.eventFunc as Record<\n                              string,\n                              EventListenerOrEventListenerObject\n                            >\n                          )[eventType]\n                        );\n                      });\n                    }\n                    Object.keys(selectedEvent).forEach(\n                      (key) => delete selectedEvent[key]\n                    );\n                  }\n                  // Clear the selectedEvent object to release references\n                });\n              });\n            }\n\n            const parent =\n              self.element instanceof Node ? self.element.parentElement : null;\n            const removedElement:\n              | Element\n              | TemplateElement\n              | Comment\n              | DocumentFragment = self.element; // Store reference\n\n            if (parent) {\n              if (spacer) {\n                const dumy = document.createElement(\"template\");\n                parent.replaceChild(dumy, self.element as Node);\n                self.element = dumy; // Update scope's element reference\n              } else {\n                parent.removeChild(self.element as Node);\n              }\n            } else if (configs.debug) {\n              console.warn(\n                `Cannot remove template \"${tmplId}\": element not in DOM.`\n              );\n            }\n\n            if (self.afterRemove) {\n              try {\n                self.afterRemove();\n              } catch (e) {\n                console.error(\"Error in afterRemove:\", e);\n              }\n            }\n            return removedElement;\n          },\n          appendTo: function (parentElement: Element): ComponentScope {\n            const self = this as ComponentScope;\n            if (self.beforeAppendTo) {\n              try {\n                self.beforeAppendTo();\n              } catch (e) {\n                console.error(\"Error in beforeAppendTo:\", e);\n              }\n            }\n\n            if (parentElement && self.element instanceof Node) {\n              parentElement.appendChild(self.element);\n            } else if (configs.debug) {\n              console.warn(\n                `Cannot append template \"${tmplId}\": parentElement or scope.element is missing or not a Node.`\n              );\n            }\n\n            if (self.afterAppendTo) {\n              setTimeout(() => {\n                try {\n                  self.afterAppendTo!();\n                } catch (e) {\n                  console.error(\"Error in afterAppendTo:\", e);\n                }\n              }, 0);\n            }\n            return self;\n          },\n          release: function (): void {\n            /* Implementation below */\n          },\n          render: function (newData: Record<string, any>): ComponentScope {\n            /* Implementation below */ return this;\n          },\n          refresh: function (reflashData: Record<string, any>): ComponentScope {\n            /* Implementation below */ return this;\n          },\n          reflash: function (reflashData: Record<string, any>): ComponentScope {\n            /* Implementation below */ return this;\n          },\n        } as ComponentScope); // Cast to ComponentScope\n\n        if (!component._id) {\n          component._id = tools.genId(tmplId);\n        }\n        component[dataKeyName] = data;\n        if (component[statusKeyName] == undefined) {\n          component[statusKeyName] = {};\n        }\n\n        const hasParent = wrapperElement instanceof Element;\n        const temp = document.createElement(\"template\");\n\n        if (configs.printExecTime) console.time(`render: ${tmplId}`);\n\n        let returnTarget: Node | null = null;\n        let renderedHTML: string | null = null;\n        try {\n          renderedHTML = !data\n            ? `<template data-co-empty-template=\"${tmplId}\"></template>`\n            : sourceGenFunc!.call(\n                // Use non-null assertion\n                wrapperElement || null,\n                data,\n                component[statusKeyName],\n                component,\n                compomint.i18n[tmplId],\n                compomint,\n                tmpl,\n                lazyScope,\n                configs.debug // Pass debug flag for __debugger\n              );\n        } catch (e: any) {\n          if (configs.throwError) {\n            console.error(\n              `Runtime error during render of \"${tmplId}\":`,\n              e.message\n            );\n            console.log(\"--- Data ---\", data, \"------------\");\n            try {\n              // Attempt re-run with debugger\n              sourceGenFunc!.call(\n                wrapperElement || null,\n                data,\n                component[statusKeyName],\n                component,\n                compomint.i18n[tmplId],\n                lazyScope,\n                true\n              );\n            } catch {\n              /* Ignore */\n            }\n            throw e;\n          } else {\n            console.warn(\n              `Render failed for \"${tmplId}\". Returning scope with comment node.`\n            );\n            component.element = document.createComment(\n              `Render Error: ${tmplId}`\n            ) as any;\n            return component;\n          }\n        }\n        if (configs.printExecTime) console.timeEnd(`render: ${tmplId}`);\n\n        temp.innerHTML = renderedHTML!;\n        let docFragment: DocumentFragment | Element | TemplateElement =\n          temp.content || temp;\n\n        if (\n          (docFragment as any).tagName == \"TEMPLATE\" &&\n          !(temp as any).content\n        ) {\n          // Check for IE11 case\n          const children = Array.from(docFragment.childNodes);\n          docFragment = document.createDocumentFragment();\n          children.forEach((child) => docFragment.appendChild(child));\n        }\n\n        if (hasParent && wrapperElement) {\n          while (wrapperElement.firstChild) {\n            wrapperElement.removeChild(wrapperElement.firstChild);\n          }\n          component.wrapperElement = wrapperElement;\n        }\n\n        // Handle shadow DOM creation\n        const shadowStyle = (docFragment as any).querySelector\n          ? (docFragment as any).querySelector(\"style\")\n          : null;\n        if (shadowStyle && (docFragment as any).querySelector) {\n          // Check if querySelector exists\n          const host = document.createElement(tmplId); // Use tmplId as host tag name\n          try {\n            const shadow = host.attachShadow({ mode: \"open\" });\n            while (docFragment.firstChild) {\n              shadow.appendChild(docFragment.firstChild);\n            }\n            docFragment = host; // Replace fragment with the host element\n          } catch (e) {\n            console.error(\n              `Failed to attach shadow DOM for template \"${tmplId}\":`,\n              e\n            );\n            // Proceed without shadow DOM if attachShadow fails\n          }\n        }\n\n        if (docFragment.firstChild && docFragment.firstChild.nodeType == 8) {\n          returnTarget = docFragment.firstChild;\n        } else if (childElementCount(docFragment) == 1) {\n          returnTarget = firstElementChild(docFragment);\n          if (hasParent && wrapperElement && returnTarget) {\n            if (component.beforeAppendTo) {\n              try {\n                component.beforeAppendTo();\n              } catch (e) {\n                console.error(\"Error in beforeAppendTo:\", e);\n              }\n            }\n            wrapperElement.appendChild(returnTarget);\n            if (component.afterAppendTo) {\n              setTimeout(() => {\n                try {\n                  component.afterAppendTo!();\n                } catch (e) {\n                  console.error(\"Error in afterAppendTo:\", e);\n                }\n              }, 0);\n            }\n          }\n        } else {\n          if (hasParent && wrapperElement) {\n            if (component.beforeAppendTo) {\n              try {\n                component.beforeAppendTo();\n              } catch (e) {\n                console.error(\"Error in beforeAppendTo:\", e);\n              }\n            }\n            wrapperElement.appendChild(docFragment);\n            if (component.afterAppendTo) {\n              setTimeout(() => {\n                try {\n                  component.afterAppendTo!();\n                } catch (e) {\n                  console.error(\"Error in afterAppendTo:\", e);\n                }\n              }, 0);\n            }\n            returnTarget = wrapperElement;\n          } else {\n            returnTarget = docFragment;\n          }\n        }\n\n        if (data && data.$props && returnTarget instanceof Element) {\n          for (const prop in data.$props) {\n            try {\n              const value = data.$props[prop];\n              if (prop.startsWith(\"data-\")) {\n                const camelCased = prop\n                  .substring(5)\n                  .replace(/-([a-z])/g, (g) => g[1].toUpperCase());\n                (returnTarget as HTMLElement).dataset[camelCased] =\n                  String(value);\n              } else if (prop in returnTarget) {\n                (returnTarget as any)[prop] = value;\n              } else {\n                returnTarget.setAttribute(prop, String(value));\n              }\n            } catch (e: any) {\n              console.error(\n                `Error applying prop \"${prop}\" to element in template \"${tmplId}\":`,\n                e\n              );\n            }\n          }\n        }\n\n        if (returnTarget instanceof Node && returnTarget.normalize) {\n          returnTarget.normalize();\n        }\n        if (returnTarget instanceof Node) {\n          cleanNode(returnTarget);\n        }\n        component.element = returnTarget as HTMLElement | TemplateElement; // Assign final element/fragment\n\n        // Execute lazyExec functions after element is attached\n        const lazyExec = matcher.lazyExec;\n        if (data) {\n          matcher.lazyExecKeys.forEach(function (key) {\n            if (lazyScope[key] && lazyScope[key].length > 0) {\n              try {\n                lazyExec[key].call(\n                  templateEngine.rules[key.slice(0, -5)],\n                  data,\n                  lazyScope,\n                  component,\n                  docFragment as DocumentFragment | Element\n                ); // Cast needed\n              } catch (e: any) {\n                if (configs.throwError) {\n                  console.error(\n                    `Error during lazy execution of \"${key}\" for template \"${tmplId}\":`,\n                    e\n                  );\n                  throw e;\n                }\n              }\n            }\n          });\n        }\n\n        if (tools.liveReloadSupport) {\n          try {\n            tools.liveReloadSupport(component);\n          } catch (e) {\n            console.error(\"Error in liveReloadSupport:\", e);\n          }\n        }\n\n        if (callback) {\n          try {\n            callback.call(wrapperElement || null, component);\n          } catch (e: any) {\n            console.error(`Error in template callback for \"${tmplId}\":`, e);\n            if (configs.throwError) throw e;\n          }\n        }\n\n        // Define Component Methods (Render/Refresh/Release)\n        component.release = function (): void {\n          const self = this as ComponentScope;\n          const props = Object.getOwnPropertyNames(self);\n          const keepProps = [statusKeyName, \"_id\"];\n          for (let i = 0; i < props.length; i++) {\n            const prop = props[i];\n            if (\n              typeof (self as any)[prop] !== \"function\" &&\n              !keepProps.includes(prop)\n            ) {\n              delete (self as any)[prop];\n            }\n          }\n        };\n\n        component.render = function (\n          newData: Record<string, any>\n        ): ComponentScope {\n          const currentComponent = this as ComponentScope;\n          const targetElement = currentComponent.element;\n          const parent =\n            targetElement instanceof Node ? targetElement.parentElement : null;\n          const wrapper = currentComponent.wrapperElement;\n          const tmplFunc = compomint.tmpl(currentComponent.tmplId);\n\n          if (!tmplFunc) {\n            console.error(\n              `Cannot re-render: Template function for \"${currentComponent.tmplId}\" not found.`\n            );\n            return currentComponent;\n          }\n\n          const hooks = {\n            beforeAppendTo: currentComponent.beforeAppendTo,\n            afterAppendTo: currentComponent.afterAppendTo,\n            beforeRemove: currentComponent.beforeRemove,\n            afterRemove: currentComponent.afterRemove,\n            beforeRefresh: currentComponent.beforeRefresh,\n            afterRefresh: currentComponent.afterRefresh,\n          };\n\n          if (currentComponent.beforeRemove) {\n            try {\n              currentComponent.beforeRemove();\n            } catch (e) {\n              console.error(\"Error in beforeRemove during render:\", e);\n            }\n          }\n\n          let newComponent: ComponentScope;\n          if (wrapper) {\n            newComponent = tmplFunc(\n              newData,\n              wrapper,\n              undefined,\n              currentComponent\n            ); // Reuse scope object\n          } else if (parent && targetElement instanceof Node) {\n            newComponent = tmplFunc(\n              newData,\n              undefined,\n              undefined,\n              currentComponent\n            ); // Reuse scope object\n            if (newComponent.element instanceof Node) {\n              if (newComponent.beforeAppendTo) {\n                try {\n                  newComponent.beforeAppendTo();\n                } catch (e) {\n                  console.error(\"Error in beforeAppendTo during render:\", e);\n                }\n              }\n              parent.replaceChild(newComponent.element, targetElement);\n              if (newComponent.afterAppendTo) {\n                setTimeout(() => {\n                  try {\n                    newComponent.afterAppendTo!();\n                  } catch (e) {\n                    console.error(\"Error in afterAppendTo during render:\", e);\n                  }\n                }, 0);\n              }\n            } else if (configs.debug) {\n              console.warn(\n                `Re-render of \"${currentComponent.tmplId}\" resulted in no element or target was missing.`\n              );\n            }\n          } else {\n            // No parent, just create new scope (likely detached)\n            newComponent = tmplFunc(\n              newData,\n              undefined,\n              undefined,\n              currentComponent\n            );\n          }\n\n          if (currentComponent.afterRemove) {\n            try {\n              currentComponent.afterRemove();\n            } catch (e) {\n              console.error(\"Error in afterRemove during render:\", e);\n            }\n          }\n\n          Object.assign(newComponent, hooks); // Restore hooks\n          return newComponent;\n        };\n\n        component.refresh = function (\n          reflashData: Record<string, any>\n        ): ComponentScope {\n          const currentComponent = this as ComponentScope;\n          const currentData = currentComponent[dataKeyName];\n          if (currentComponent.beforeRefresh) {\n            try {\n              currentComponent.beforeRefresh();\n            } catch (e) {\n              console.error(\"Error in beforeRefresh:\", e);\n            }\n          }\n          const newData = Object.assign({}, currentData || {}, reflashData);\n          const newComponent = currentComponent.render(newData);\n          if (currentComponent.afterRefresh) {\n            try {\n              currentComponent.afterRefresh();\n            } catch (e) {\n              console.error(\"Error in afterRefresh:\", e);\n            }\n          }\n          return newComponent;\n        };\n\n        component.reflash = component.refresh;\n\n        return component;\n      }; // End of renderingFunc definition\n\n    Object.defineProperty(renderingFunc, \"name\", {\n      value: `render_${tmplId}`,\n      writable: false,\n    });\n\n    if (tmplId) {\n      const tmplMeta: TemplateMeta = configs.debug\n        ? {\n            renderingFunc: renderingFunc,\n            source: escapeHtml.escape(\n              `function ${tmplId}_source (${templateEngine.keys.dataKeyName}, ${templateEngine.keys.statusKeyName}, ${templateEngine.keys.componentKeyName}, ${templateEngine.keys.i18nKeyName}, __lazyScope, __debugger) {\\n${source}\\n}`\n            ),\n            templateText: escapeHtml.escape(templateText),\n          }\n        : {\n            renderingFunc: renderingFunc,\n          };\n      cachedTmpl.set(tmplId, tmplMeta);\n\n      const tmplIdNames = tmplId.split(\"-\");\n      if (tmplIdNames.length > 1) {\n        const group = tmplIdNames[0];\n        let groupObj = tmpl[group];\n        if (!groupObj) {\n          tmpl[group] = groupObj = {};\n        }\n        const tmplIdSub = tmplIdNames\n          .slice(1)\n          .map((part, index) =>\n            index === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)\n          )\n          .join(\"\");\n        groupObj[tmplIdSub] = tmplMeta.renderingFunc;\n      }\n    }\n    return renderingFunc;\n  }); // End of templateBuilder\n\ncompomint.remapTmpl = function (json: Record<string, string>): void {\n  Object.keys(json).forEach(function (oldKey: string) {\n    const newKey = json[oldKey];\n    const meta = cachedTmpl.get(oldKey);\n    if (meta) {\n      cachedTmpl.set(newKey, meta);\n      if (configs.debug)\n        console.log(`Remapped template \"${oldKey}\" to \"${newKey}\"`);\n    } else if (configs.debug) {\n      console.warn(\n        `Cannot remap template: Old key \"${oldKey}\" not found in cache.`\n      );\n    }\n  });\n};\n\ncompomint.tmpl = function (tmplId: string): RenderingFunction | null {\n  const tmplMeta = cachedTmpl.get(tmplId);\n  return tmplMeta ? tmplMeta.renderingFunc : null;\n};\n\nconst safeTemplate = function (\n  source: Element | string\n): Element | TemplateElement {\n  let template: TemplateElement;\n  if (source instanceof Element) {\n    if (source.tagName === \"TEMPLATE\") return source as TemplateElement;\n    return source; // Assume it's a container element\n  } else if (typeof source !== \"string\") {\n    if (configs.debug)\n      console.warn(\n        \"safeTemplate received non-string/non-element source:\",\n        source\n      );\n    source = \"\";\n  }\n\n  template = document.createElement(\"template\");\n  if (isSupportTemplateTag) {\n    const encodedSource = source.replace(\n      /<(?!template|\\/template|body|\\/body|html|\\/html|head|\\/head|style|\\/style|script|\\/script|link|\\/link|meta|\\/meta|!--)/gi,\n      \"&lt;\"\n    );\n    template.innerHTML = encodedSource;\n  } else {\n    const encodedSource = source\n      .replace(\n        /<(?!template|\\/template|body|\\/body|html|\\/html|head|\\/head|style|\\/style|script|\\/script|link|\\/link|meta|\\/meta|!--)/gi,\n        \"&lt;\"\n      )\n      .replace(/<template/g, '<script type=\"template\"')\n      .replace(/<\\/template>/g, \"</script>\");\n    template.innerHTML = encodedSource;\n  }\n  return template;\n};\n\nconst addTmpl: CompomintGlobal[\"addTmpl\"] = (compomint.addTmpl = function (\n  tmplId,\n  element,\n  templateEngine\n) {\n  let templateText =\n    element instanceof Element ? element.innerHTML : String(element);\n  templateText = escapeHtml.unescape(templateText.replace(/<!---|--->/gi, \"\"));\n  return templateBuilder(tmplId, templateText, templateEngine);\n});\n\nconst addTmpls: CompomintGlobal[\"addTmpls\"] = (compomint.addTmpls = function (\n  source,\n  removeInnerTemplate,\n  templateEngine\n) {\n  if (typeof removeInnerTemplate !== \"boolean\" && templateEngine == undefined) {\n    templateEngine = removeInnerTemplate as Partial<TemplateEngine> | undefined;\n    removeInnerTemplate = false;\n  } else {\n    removeInnerTemplate = !!removeInnerTemplate;\n  }\n\n  const container = safeTemplate(source);\n  const content = (container as TemplateElement).content || container; // Use content if available\n  const tmplNodes = content.querySelectorAll<Element>(\n    'template[id], script[type=\"text/template\"][id], script[type=\"text/compomint\"][id]'\n  );\n\n  tmplNodes.forEach((node) => {\n    const tmplId = node.id;\n    if (!tmplId) return;\n\n    if ((node as HTMLElement).dataset.coLoadScript !== undefined) {\n      addTmpl(tmplId, node, templateEngine)({}); // Execute immediately if data-co-load-script\n    } else {\n      addTmpl(tmplId, node, templateEngine);\n    }\n\n    if (removeInnerTemplate && node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  });\n  return container;\n});\n\nconst addTmplByUrl: CompomintGlobal[\"addTmplByUrl\"] = (compomint.addTmplByUrl =\n  function compomint_addTmplByUrl(importData, option, callback) {\n    if (!callback && typeof option === \"function\") {\n      callback = option;\n      option = {};\n    }\n\n    const defaultOptions = {\n      loadScript: true,\n      loadStyle: true,\n      loadLink: true,\n      templateEngine: undefined,\n    };\n    const mergedOptions = Object.assign(\n      {},\n      defaultOptions,\n      option as Record<string, any>\n    ); // Ensure option is object\n\n    const importDataParser = (\n      obj: string | any\n    ): { url: string; option: Record<string, any> } | null => {\n      if (typeof obj === \"string\") {\n        return { url: obj, option: mergedOptions };\n      } else if (obj && typeof obj === \"object\" && obj.url) {\n        return {\n          url: obj.url,\n          option: Object.assign({}, mergedOptions, obj.option),\n        };\n      } else {\n        console.error(\"Invalid import data format in addTmplByUrl:\", obj);\n        return null;\n      }\n    };\n\n    const appendElements = (\n      elements: NodeListOf<Element> | Element[]\n    ): void => {\n      elements.forEach((element) => {\n        if (!element) return;\n        if (element.id) {\n          const oldElement = document.getElementById(element.id);\n          if (oldElement) oldElement.parentNode?.removeChild(oldElement);\n        }\n        if (\n          element.tagName === \"SCRIPT\" ||\n          element.tagName === \"LINK\" ||\n          element.tagName === \"STYLE\"\n        ) {\n          document.head.appendChild(element);\n        } else {\n          document.body.appendChild(element);\n        }\n      });\n    };\n\n    const importFunc = (\n      source: string,\n      currentOption: Record<string, any>\n    ): void => {\n      const templateContainer = safeTemplate(source);\n      addTmpls(templateContainer, false, currentOption.templateEngine);\n      const content =\n        (templateContainer as TemplateElement).content || templateContainer;\n\n      if (currentOption.loadLink) {\n        const links = content.querySelectorAll<HTMLLinkElement>(\n          'link[rel=\"stylesheet\"]'\n        );\n        appendElements(links);\n      }\n      if (currentOption.loadStyle) {\n        const styles = content.querySelectorAll<HTMLStyleElement>(\"style[id]\");\n        appendElements(styles);\n      }\n      if (currentOption.loadScript) {\n        const scripts = content.querySelectorAll<HTMLScriptElement>(\n          'script:not([type]), script[type=\"text/javascript\"], script[type=\"module\"]'\n        );\n        const executableScripts = Array.from(scripts)\n          .filter((node) => {\n            let parent = node.parentNode;\n            while (parent) {\n              if (\n                parent.nodeName === \"TEMPLATE\" ||\n                (parent.nodeName === \"SCRIPT\" &&\n                  (parent as HTMLScriptElement).type.includes(\"template\"))\n              )\n                return false;\n              parent = parent.parentNode;\n            }\n            return true;\n          })\n          .map((node) => {\n            const scriptElm = document.createElement(\"script\");\n            node\n              .getAttributeNames()\n              .forEach((name) =>\n                scriptElm.setAttribute(name, node.getAttribute(name)!)\n              );\n            if (node.innerHTML) scriptElm.textContent = node.innerHTML;\n            return scriptElm;\n          });\n        appendElements(executableScripts);\n      }\n    };\n\n    const loadResource = (dataItem: string | any): Promise<void> => {\n      return new Promise((resolve, reject) => {\n        const parsedData = importDataParser(dataItem);\n        if (!parsedData) {\n          resolve(); // Resolve immediately for invalid data\n          return;\n        }\n        const src = parsedData.url;\n        const currentOption = parsedData.option;\n\n        if (src.endsWith(\".js\")) {\n          const script = genElement(\"script\", {\n            async: true,\n            src: src,\n          }) as HTMLScriptElement;\n          script.addEventListener(\"load\", () => resolve());\n          script.addEventListener(\"error\", () => {\n            console.error(`Failed to load script: ${src}`);\n            reject(new Error(`Failed to load script: ${src}`));\n          });\n          document.head.appendChild(script);\n        } else if (src.endsWith(\".css\")) {\n          const link = genElement(\"link\", {\n            type: \"text/css\",\n            rel: \"stylesheet\",\n            href: src,\n          }) as HTMLLinkElement;\n          link.addEventListener(\"load\", () => resolve());\n          link.addEventListener(\"error\", () => {\n            console.error(`Failed to load stylesheet: ${src}`);\n            reject(new Error(`Failed to load stylesheet: ${src}`));\n          });\n          document.head.appendChild(link);\n        } else {\n          requestFunc(src, null, (source, status) => {\n            if (status === 200 || status === 0) {\n              try {\n                importFunc(source!, currentOption); // Use non-null assertion for source\n                resolve(); // Resolve after successful processing\n              } catch (e) {\n                console.error(`Error processing imported HTML from ${src}:`, e);\n                reject(\n                  new Error(`Error processing imported HTML from ${src}: ${e}`)\n                );\n              }\n            } else {\n              console.error(\n                `Failed to fetch template file: ${src} (Status: ${status})`\n              );\n              reject(\n                new Error(\n                  `Failed to fetch template file: ${src} (Status: ${status})`\n                )\n              );\n            }\n          });\n        }\n      });\n    };\n\n    // Handle null or undefined importData\n    if (importData == null) {\n      if (callback) {\n        callback();\n        return;\n      } else {\n        return Promise.resolve();\n      }\n    }\n\n    // Create the promise for all operations\n    const operationPromise = Array.isArray(importData)\n      ? importData.length === 0\n        ? Promise.resolve()\n        : Promise.all(importData.map(loadResource))\n            .then(() => {})\n            .catch((err) => {\n              console.error(\"Error loading resources in addTmplByUrl:\", err);\n              throw err; // Re-throw the error to allow operationPromise to reject\n            })\n      : loadResource(importData).catch((err) => {\n          console.error(\"Error loading resource in addTmplByUrl:\", err);\n          throw err; // Re-throw the error to allow operationPromise to reject\n        });\n\n    // If callback is provided, use it; otherwise return the promise\n    if (callback) {\n      operationPromise\n        .then(() => callback())\n        .catch((err) => {\n          // Log error but still call callback for backward compatibility\n          console.error(\"Error in addTmplByUrl callback mode:\", err);\n          callback();\n        });\n      return;\n    } else {\n      return operationPromise;\n    }\n  });\n\nconst requestFunc = function (\n  url: string,\n  option: RequestInit | null,\n  callback: (\n    responseText: string | null,\n    status: number,\n    xhr: XMLHttpRequest\n  ) => void\n): void {\n  const xmlhttp = new XMLHttpRequest();\n\n  xmlhttp.onreadystatechange = function () {\n    if (xmlhttp.readyState == XMLHttpRequest.DONE) {\n      if (xmlhttp.status == 200 || xmlhttp.status === 0) {\n        callback(xmlhttp.responseText, xmlhttp.status, xmlhttp);\n      } else {\n        if (xmlhttp.status == 404)\n          console.error(`Error 404: Not Found - ${url}`);\n        else if (xmlhttp.status >= 400)\n          console.error(`HTTP Error ${xmlhttp.status} for ${url}`);\n        else console.error(`Request failed for ${url}`, xmlhttp.statusText);\n        callback(null, xmlhttp.status, xmlhttp);\n      }\n    }\n  };\n\n  xmlhttp.onerror = function () {\n    console.error(`Network error requesting ${url}`);\n    callback(null, 0, xmlhttp);\n  };\n  xmlhttp.ontimeout = function () {\n    console.error(`Request timed out for ${url}`);\n    callback(null, 408, xmlhttp);\n  };\n\n  try {\n    const method = (option && option.method) || \"GET\";\n    xmlhttp.open(method, url, true);\n\n    if (option) {\n      if ((option as any).timeout) xmlhttp.timeout = (option as any).timeout;\n      const headers = option.headers as Record<string, string>;\n      if (headers) {\n        Object.keys(headers).forEach((key) => {\n          xmlhttp.setRequestHeader(key, headers[key]);\n        });\n      }\n      xmlhttp.send((option.body as any) || null);\n    } else {\n      xmlhttp.send();\n    }\n  } catch (e: any) {\n    console.error(`Error sending request to ${url}:`, e);\n    callback(null, 0, xmlhttp);\n  }\n};\n\ncompomint.i18n = {};\n\ncompomint.addI18n = function (\n  fullKey: string,\n  i18nObj: Record<string, any>\n): void {\n  if (\n    !fullKey ||\n    typeof fullKey !== \"string\" ||\n    !i18nObj ||\n    typeof i18nObj !== \"object\"\n  ) {\n    console.error(\"Invalid arguments for addI18n:\", fullKey, i18nObj);\n    return;\n  }\n\n  const langKeyNames = fullKey.split(\".\");\n  let target: any = compomint.i18n;\n  const keyLength = langKeyNames.length - 1;\n\n  langKeyNames.forEach(function (key: string, i: number) {\n    if (!key) return;\n\n    if (keyLength === i) {\n      // Check if any language value is an array\n      const hasArrayValues = Object.keys(i18nObj).some((lang) =>\n        Array.isArray(i18nObj[lang])\n      );\n\n      if (hasArrayValues) {\n        // Handle arrays - create array structure\n        if (!target[key]) {\n          target[key] = [];\n        }\n\n        // Process each language's array\n        Object.keys(i18nObj)\n          .filter((lang) => Array.isArray(i18nObj[lang]))\n          .forEach((lang) => {\n            const array = i18nObj[lang];\n            array.forEach((item: any, index: number) => {\n              if (!target[key][index]) {\n                target[key][index] = {};\n              }\n              if (item instanceof Object && !Array.isArray(item)) {\n                Object.keys(item).forEach((subKey) => {\n                  compomint.addI18n(\n                    fullKey + \".\" + index + \".\" + subKey,\n                    item[subKey]\n                  );\n                });\n              }\n            });\n          });\n      } else {\n        // Handle regular i18n function\n        if (!target[key]) {\n          target[key] = function (defaultText?: string): string {\n            const lang = document.documentElement.lang || \"en\";\n            let label = i18nObj[lang];\n            if (label === undefined || label === null) {\n              label = defaultText;\n              if (configs.debug)\n                console.warn(\n                  `i18n: Label key [\"${fullKey}\"] for lang \"${lang}\" is missing. Using default: \"${defaultText}\"`\n                );\n            }\n            return label !== undefined && label !== null ? String(label) : \"\";\n          };\n        }\n        // Handle nested objects within the language definitions\n        Object.keys(i18nObj)\n          .filter(\n            (lang) =>\n              i18nObj[lang] instanceof Object && !Array.isArray(i18nObj[lang])\n          ) // Check for plain objects\n          .forEach((subKey) => {\n            compomint.addI18n(fullKey + \".\" + subKey, i18nObj[subKey]);\n            // delete i18nObj[subKey]; // Avoid deleting if it's also a language key\n          });\n      }\n    } else {\n      if (!target[key] || typeof target[key] === \"function\") {\n        target[key] = {};\n      }\n      target = target[key];\n    }\n  });\n};\n\ncompomint.addI18ns = function (i18nObjs: Record<string, any>): void {\n  // Cache for target path resolution to avoid repeated splits\n  const targetCache = new Map<string, any>();\n\n  function getTargetPath(fullKey: string): any {\n    if (targetCache.has(fullKey)) {\n      return targetCache.get(fullKey);\n    }\n\n    const keyParts = fullKey.split(\".\");\n    let target = compomint.i18n;\n    for (let i = 0; i < keyParts.length - 1; i++) {\n      if (!target[keyParts[i]]) {\n        target[keyParts[i]] = {};\n      }\n      target = target[keyParts[i]];\n    }\n\n    targetCache.set(fullKey, target);\n    return target;\n  }\n\n  function isTranslationObject(value: any): boolean {\n    // Fast check: if it has nested objects, it's not a translation\n    for (const key in value) {\n      const val = value[key];\n      const type = typeof val;\n      if (type !== \"string\" && type !== \"number\" && type !== \"boolean\") {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function processNested(obj: any, keyPath: string = \"\"): void {\n    for (const key in obj) {\n      const value = obj[key];\n      const fullKey = keyPath ? keyPath + \".\" + key : key;\n\n      if (Array.isArray(value)) {\n        // Handle array at this level - optimized version\n        const target = getTargetPath(fullKey);\n        const finalKey = fullKey.split(\".\").pop()!;\n\n        if (!target[finalKey]) {\n          target[finalKey] = [];\n        }\n\n        // Process each array item with reduced function calls\n        for (let index = 0; index < value.length; index++) {\n          const item = value[index];\n          if (!target[finalKey][index]) {\n            target[finalKey][index] = {};\n          }\n\n          if (item && typeof item === \"object\") {\n            // Direct processing without recursive addI18n calls\n            for (const itemKey in item) {\n              const itemValue = item[itemKey];\n              if (itemValue && typeof itemValue === \"object\") {\n                // Create the i18n function directly\n                const itemPath = fullKey + \".\" + index + \".\" + itemKey;\n                compomint.addI18n(itemPath, itemValue);\n              }\n            }\n          }\n        }\n      } else if (value && typeof value === \"object\") {\n        if (isTranslationObject(value)) {\n          // This is a translation object, use addI18n\n          compomint.addI18n(fullKey, value);\n        } else {\n          // This is a nested structure, continue processing\n          processNested(value, fullKey);\n        }\n      } else {\n        // Primitive value, use addI18n\n        compomint.addI18n(fullKey, value);\n      }\n    }\n  }\n\n  processNested(i18nObjs);\n};\n\nlet elementCount = 0;\ntools.genId = function (tmplId: string): string {\n  elementCount++;\n  return tmplId + elementCount;\n};\n\nconst applyElementProps = (tools.applyElementProps = function (\n  element: HTMLElement,\n  attrs: Record<string, any>\n): Element {\n  Object.keys(attrs).forEach(function (key) {\n    const value = attrs[key];\n    const propName = key === \"class\" ? \"className\" : key;\n\n    try {\n      if (key === \"style\" && typeof value === \"object\" && value !== null) {\n        Object.assign(element.style, value); // Assign style object\n      } else if (\n        key === \"dataset\" &&\n        typeof value === \"object\" &&\n        value !== null\n      ) {\n        Object.assign((element as HTMLElement).dataset, value); // Assign dataset object\n      } else if (key.startsWith(\"on\") && typeof value === \"function\") {\n        // Directly assign event handlers like onclick, onmouseover\n        (element as any)[key.toLowerCase()] = value;\n      } else if (propName in element) {\n        (element as any)[propName] = value;\n      } else {\n        element.setAttribute(key, String(value));\n      }\n    } catch (e: any) {\n      console.error(\n        `Error setting attribute/property \"${key}\" on <${element.tagName}>:`,\n        e\n      );\n    }\n  });\n  return element;\n});\n\nconst genElement = (tools.genElement = function (\n  tagName: string,\n  attrs: Record<string, any> | string | Node | (string | Node)[] = {},\n  ...children: (string | Node)[]\n): Element {\n  const element = document.createElement(tagName);\n  let actualAttrs: Record<string, any> = {};\n\n  if (typeof attrs === \"string\") {\n    children.unshift(attrs); // Prepend string as first child\n  } else if (attrs instanceof Node) {\n    children.unshift(attrs); // Prepend Node as first child\n  } else if (Array.isArray(attrs)) {\n    children = attrs.concat(children); // Concatenate arrays\n  } else {\n    actualAttrs = attrs; // It's an attributes object\n  }\n\n  // Set attributes/properties\n  applyElementProps(element, actualAttrs);\n\n  // Append children\n  children.forEach((child) => {\n    if (typeof child === \"string\") {\n      element.appendChild(document.createTextNode(child));\n    } else if (child instanceof Node) {\n      element.appendChild(child);\n    }\n  });\n  return element;\n});\n\ntools.props = function (...propsObjects: Record<string, any>[]): string {\n  if (!propsObjects || propsObjects.length === 0) return \"\";\n  const mergedProps = Object.assign({}, ...propsObjects);\n  const propStrArray: string[] = [];\n  Object.keys(mergedProps).forEach(function (key) {\n    const value = mergedProps[key];\n    if (value || value === 0) {\n      const escapedValue = String(value).replace(/\"/g, \"&quot;\");\n      propStrArray.push(`${key}=\"${escapedValue}\"`);\n    }\n  });\n  return propStrArray.join(\" \");\n};\n\n// Add built-in template\napplyBuiltInTemplates(addTmpl);\n\nexport { compomint, tmpl };\n","import {\n  ComponentScope,\n  LazyScope,\n  TemplateEngine,\n  TemplateRule,\n  TemplateElement,\n  CompomintConfigs,\n  CompomintGlobal,\n} from \"./type\";\n\nimport {\n  firstElementChild,\n  childElementCount,\n  stringToElement,\n  isPlainObject,\n} from \"./utils\";\n\n//\n// Default template settings\n//\nconst defaultTemplateEngine = (\n  configs: CompomintConfigs,\n  compomint: CompomintGlobal\n): TemplateEngine => ({\n  rules: {\n    style: {\n      pattern: /(\\<style id=[\\s\\S]+?\\>[\\s\\S]+?\\<\\/style\\>)/g,\n      exec: function (style): string {\n        // Create a temporary element to parse the style tag\n        const dumy = document.createElement(\"template\");\n        dumy.innerHTML = style;\n        const styleNode = (dumy.content || dumy).querySelector(\"style\");\n        if (!styleNode || !styleNode.id) return \"\"; // Skip if no style node or ID\n        const oldStyleNode = document.getElementById(styleNode.id);\n        if (oldStyleNode) oldStyleNode.parentNode?.removeChild(oldStyleNode);\n        document.head.appendChild(styleNode);\n        return \"\";\n      },\n    },\n    commentArea: {\n      pattern: /##\\*([\\s\\S]+?)##/g,\n      exec: function (commentArea: string): string {\n        // Return an empty string to remove the comment block\n        return ``;\n      },\n    },\n    preEvaluate: {\n      pattern: /##!([\\s\\S]+?)##/g,\n      exec: function (preEvaluate: string, tmplId: string): string {\n        try {\n          // Execute the code in a new function context\n          new Function(\"compomint\", \"tmplId\", preEvaluate)(compomint, tmplId);\n        } catch (e: any) {\n          if (configs.throwError) {\n            console.error(\n              `Template preEvaluate error in \"${tmplId}\", ${e.name}: ${e.message}`\n            );\n            throw e;\n          } else {\n            console.warn(\n              `Template preEvaluate error in \"${tmplId}\", ${e.name}: ${e.message}`\n            );\n          }\n        }\n        return ``;\n      },\n    },\n    interpolate: {\n      pattern: /##=([\\s\\S]+?)##/g,\n      exec: function (interpolate: string): string {\n        // Construct JavaScript code to interpolate the value\n        const interpolateSyntax = `typeof (interpolate)=='function' ? (interpolate)() : (interpolate)`;\n        return `';\\n(() => {let __t, interpolate=${interpolate};\\n__p+=((__t=(${interpolateSyntax}))==null ? '' : String(__t) );})();\\n__p+='`; // Ensure string conversion\n      },\n    },\n    escape: {\n      pattern: /##-([\\s\\S]+?)##/g,\n      exec: function (escape: string): string {\n        const escapeSyntax = `compomint.tools.escapeHtml.escape(typeof (escape)=='function' ? (escape)() : (escape))`;\n        // Construct JavaScript code to escape HTML characters in the value\n        return `';\\n(() => {let __t, escape=${escape};\\n__p+=((__t=(${escapeSyntax}))==null ? '' : String(__t) );})();\\n__p+='`; // Ensure string conversion before escape\n      },\n    },\n    elementProps: {\n      pattern: /data-co-props=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (props: string): string {\n        const source = `';\\nconst eventId = (__lazyScope.elementPropsArray.length);\\n__p+='data-co-props=\"'+eventId+'\"';\\n\n__lazyScope.elementPropsArray[eventId] = ${props};\\n__p+='`; // Store props in lazy scope\n        return source;\n      },\n      lazyExec: function (\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element\n      ): void {\n        // Iterate over stored props and apply them to elements\n        lazyScope.elementPropsArray.forEach(function (\n          props: Record<string, any> | null,\n          eventId: number\n        ) {\n          if (!props) return;\n          // Find the element with the corresponding data-co-props attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-props=\"${eventId}\"]`\n          );\n          // Remove the temporary attribute and set the properties\n          if (!$elementTrigger) return;\n          delete ($elementTrigger as HTMLElement).dataset.coProps;\n          Object.keys(props).forEach(function (key: string) {\n            $elementTrigger.setAttribute(key, String(props[key])); // Ensure value is string\n          });\n        });\n      },\n    },\n    namedElement: {\n      pattern: /data-co-named-element=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (key: string): string {\n        const source = `';\\nconst eventId = (__lazyScope.namedElementArray.length);\\n__p+='data-co-named-element=\"'+eventId+'\"';\\n\n__lazyScope.namedElementArray[eventId] = ${key};\\n__p+='`; // Store the key in lazy scope\n        return source;\n      },\n      lazyExec: function (\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element\n      ): void {\n        // Iterate over stored keys and assign elements to the component\n        lazyScope.namedElementArray.forEach(function (\n          key: string,\n          eventId: number\n        ) {\n          // Find the element with the corresponding data-co-named-element attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-named-element=\"${eventId}\"]`\n          );\n          // Assign the element to the component using the key\n          if (!$elementTrigger) {\n            if (configs.debug)\n              console.warn(\n                `Named element target not found for ID ${eventId} in template ${component.tmplId}`\n              );\n            return;\n          }\n          delete ($elementTrigger as HTMLElement).dataset.coNamedElement;\n          component[key] = $elementTrigger;\n        });\n      },\n    },\n    elementRef: {\n      pattern: /data-co-element-ref=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (key: string): string {\n        const source = `';\\nvar eventId = (__lazyScope.elementRefArray.length);\\n__p+='data-co-element-ref=\"'+eventId+'\"';\nvar ${key} = null;\\n__lazyScope.elementRefArray[eventId] = function(target) {${key} = target;};\\n__p+='`; // Store a function to assign the element\n        return source;\n      },\n      lazyExec: function (\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element\n      ): void {\n        // Iterate over stored functions and call them with the corresponding elements\n        lazyScope.elementRefArray.forEach(function (\n          func: (target: Element) => void,\n          eventId: number\n        ) {\n          // Find the element with the corresponding data-co-element-ref attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-element-ref=\"${eventId}\"]`\n          );\n          // Call the stored function with the element\n          if (!$elementTrigger) {\n            if (configs.debug)\n              console.warn(\n                `Element ref target not found for ID ${eventId} in template ${component.tmplId}`\n              );\n            return;\n          }\n          delete ($elementTrigger as HTMLElement).dataset.coElementRef;\n          func.call($elementTrigger, $elementTrigger);\n        });\n      },\n    },\n    elementLoad: {\n      pattern: /data-co-load=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (elementLoad: string): string {\n        const elementLoadSplitArray = elementLoad.split(\"::\");\n        // Store the load function and custom data in lazy scope\n        const source = `';\\nconst eventId = (__lazyScope.elementLoadArray.length);\\n__p+='data-co-load=\"'+eventId+'\"';\n__lazyScope.elementLoadArray[eventId] = {loadFunc: ${elementLoadSplitArray[0]}, customData: ${elementLoadSplitArray[1]}};\\n__p+='`; // 'customData' is determined when compiled, so it does not change even if refreshed.\n        return source;\n      },\n      lazyExec: function (\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element\n      ): void {\n        // Iterate over stored load functions and execute them with the corresponding elements\n        lazyScope.elementLoadArray.forEach(function (\n          elementLoad: { loadFunc: Function; customData: Record<string, any> },\n          eventId: number\n        ) {\n          // Find the element with the corresponding data-co-load attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-load=\"${eventId}\"]`\n          );\n          if (!$elementTrigger) {\n            if (configs.debug)\n              console.warn(\n                `Element load target not found for ID ${eventId} in template ${component.tmplId}`\n              );\n            return;\n          }\n          // Execute the load function with the element and context\n          delete ($elementTrigger as HTMLElement).dataset.coLoad;\n          try {\n            if (typeof elementLoad.loadFunc === \"function\") {\n              const loadFuncParams: [\n                Element,\n                Element,\n                {\n                  data: Record<string, any>;\n                  element: Element;\n                  customData: Record<string, any>;\n                  component: ComponentScope;\n                  compomint: CompomintGlobal;\n                }\n              ] = [\n                $elementTrigger,\n                $elementTrigger,\n                {\n                  data: data,\n                  element: $elementTrigger,\n                  customData: elementLoad.customData,\n                  component: component,\n                  compomint: compomint,\n                },\n              ];\n              elementLoad.loadFunc.call(...loadFuncParams);\n            }\n          } catch (e: any) {\n            console.error(\n              `Error executing elementLoad function for ID ${eventId} in template ${component.tmplId}:`,\n              e,\n              elementLoad.loadFunc\n            );\n            if (configs.throwError) throw e;\n          }\n        });\n      },\n    },\n    event: {\n      pattern: /data-co-event=\"##:([\\s\\S]+?)##\"/g,\n      exec: function (event: string): string {\n        const eventStrArray = event.split(\":::\");\n        // eventStrArray = [\"eventFunc::customData\", \"eventFunc::customData\"]\n        // Store event handlers in lazy scope\n        let source = `';\\n(() => {const eventId = (__lazyScope.eventArray.length);\\n__p+='data-co-event=\"'+eventId+'\"';\\n`;\n        const eventArray: string[] = [];\n        for (let i = 0, size = eventStrArray.length; i < size; i++) {\n          const eventSplitArray = eventStrArray[i].split(\"::\");\n          eventArray.push(\n            `{eventFunc: ${eventSplitArray[0]}, $parent: this, customData: ${eventSplitArray[1]}}`\n          );\n        }\n        source += `__lazyScope.eventArray[eventId] = [${eventArray.join(\n          \",\"\n        )}];})()\\n__p+='`;\n        return source;\n      },\n      lazyExec: function (\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element\n      ): void {\n        const self = this as TemplateRule; // Cast self to TemplateSettings\n        const attacher = self.attacher;\n        if (!attacher) return; // Guard against missing attacher\n\n        // Iterate over stored event handlers and attach them to elements\n        lazyScope.eventArray.forEach(function (\n          selectedArray: {\n            eventFunc: Function | Record<string, Function>;\n            $parent: any;\n            customData: any;\n          }[],\n          eventId: number\n        ) {\n          // Find the element with the corresponding data-co-event attribute\n          const $elementTrigger = wrapper.querySelector<Element>(\n            `[data-co-event=\"${eventId}\"]`\n          );\n          if (!$elementTrigger) {\n            if (configs.debug)\n              console.warn(\n                `Event target not found for ID ${eventId} in template ${component.tmplId}`\n              ); // Debugging: Log if target not found\n            return;\n          }\n          delete ($elementTrigger as HTMLElement).dataset.coEvent;\n          for (let i = 0, size = selectedArray.length; i < size; i++) {\n            const selected = selectedArray[i];\n            if (selected.eventFunc) {\n              if (Array.isArray(selected.eventFunc)) {\n                selected.eventFunc.forEach(function (func: Function) {\n                  attacher(\n                    self,\n                    data,\n                    lazyScope,\n                    component,\n                    wrapper,\n                    $elementTrigger,\n                    func,\n                    selected\n                  );\n                });\n              } else {\n                attacher(\n                  self,\n                  data,\n                  lazyScope,\n                  component,\n                  wrapper,\n                  $elementTrigger,\n                  selected.eventFunc,\n                  selected\n                );\n              }\n            }\n          }\n        });\n      },\n      trigger: function (target: Element, eventName: string): void {\n        const customEvent = new Event(eventName, {\n          // Dispatch a custom event on the target element\n          bubbles: true,\n          cancelable: true,\n        });\n        target.dispatchEvent(customEvent);\n      },\n      attacher: function (\n        self: any, // Type properly if possible\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element,\n        $elementTrigger: Element,\n        eventFunc: Function | Record<string, Function>,\n        eventData: Record<string, any>\n      ): void {\n        const trigger = self.trigger;\n        const $childTarget = firstElementChild(wrapper);\n        const $targetElement =\n          childElementCount(wrapper) === 1 ? $childTarget : null;\n\n        // Attach event listeners based on the type of eventFunc\n\n        if (!eventFunc) {\n          return;\n        }\n\n        const eventFuncParams: [\n          Element,\n          Event | Element | null,\n          {\n            data: Record<string, any>;\n            customData: any;\n            element: Element;\n            componentElement: Element | null | undefined;\n            component: ComponentScope;\n            compomint: CompomintGlobal;\n          }\n        ] = [\n          $elementTrigger,\n          null,\n          {\n            data: data,\n            customData: eventData.customData,\n            element: $elementTrigger,\n            componentElement: $targetElement || $childTarget?.parentElement,\n            component: component,\n            compomint: compomint,\n          },\n        ];\n\n        // Basic case: eventFunc is a single function\n        if (typeof eventFunc === \"function\") {\n          const eventListener = function (event: Event) {\n            event.stopPropagation();\n            eventFuncParams[1] = event;\n            try {\n              eventFunc.call(...eventFuncParams);\n            } catch (e: any) {\n              console.error(\n                `Error in event handler for template ${component.tmplId}:`,\n                e,\n                eventFunc\n              );\n              if (configs.throwError) throw e;\n            }\n          };\n          // Attach a click event listener for a single function\n          $elementTrigger.addEventListener(\"click\", eventListener);\n          eventData.element = $elementTrigger; // For remove eventListener\n          eventData.eventFunc = eventListener; // For remove eventListener\n\n          return;\n        }\n\n        if (!isPlainObject(eventFunc)) {\n          return;\n        }\n\n        // Advanced case: eventFunc is an object mapping event types to handlers\n        const eventMap = eventFunc as Record<string, Function>;\n        // Handle event map with multiple event types\n        const triggerName = eventMap.triggerName as unknown as\n          | string\n          | undefined; // Optional key to store trigger functions\n        if (triggerName) {\n          component.trigger = component.trigger || {};\n          component.trigger[triggerName] = {};\n        }\n\n        Object.keys(eventMap).forEach(function (eventType: string) {\n          const selectedEventFunc = eventMap[eventType];\n\n          // Handle special event types like \"load\", \"namedElement\", and \"triggerName\"\n          if (eventType === \"load\") {\n            eventFuncParams[1] = $elementTrigger;\n            try {\n              selectedEventFunc.call(...eventFuncParams);\n            } catch (e: any) {\n              console.error(\n                `Error in 'load' event handler for template ${component.tmplId}:`,\n                e,\n                selectedEventFunc\n              );\n              if (configs.throwError) throw e;\n            }\n            return;\n          } else if (eventType === \"namedElement\") {\n            component[selectedEventFunc as unknown as string] = $elementTrigger;\n            return;\n          } else if (eventType === \"triggerName\") {\n            return;\n            // Attach event listeners for other event types\n          }\n\n          const eventListener = function (event: Event) {\n            event.stopPropagation();\n            eventFuncParams[1] = event;\n            try {\n              selectedEventFunc.call(...eventFuncParams);\n            } catch (e: any) {\n              console.error(\n                `Error in '${eventType}' event handler for template ${component.tmplId}:`,\n                e,\n                selectedEventFunc\n              );\n              if (configs.throwError) throw e;\n            }\n          };\n\n          $elementTrigger.addEventListener(eventType, eventListener);\n          eventData.element = $elementTrigger; // For remove eventListener\n          eventFunc[eventType] = eventListener; // For remove eventListener\n\n          if (triggerName && trigger) {\n            component.trigger![triggerName][eventType] = function () {\n              trigger($elementTrigger, eventType);\n            };\n          }\n        });\n      },\n    },\n    element: {\n      pattern: /##%([\\s\\S]+?)##/g,\n      exec: function (target: string): string {\n        // Store element insertion information in lazy scope\n        const elementSplitArray = target.split(\"::\");\n        const source = `';\\n(() => {\nconst elementId = (__lazyScope.elementArray.length);\n__p+='<template data-co-tmpl-element-id=\"'+elementId+'\"></template>';\n__lazyScope.elementArray[elementId] = {childTarget: ${\n          elementSplitArray[0]\n        }, nonblocking: ${elementSplitArray[1] || false}};})();\n__p+='`;\n        return source;\n      },\n      lazyExec: function (\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element\n      ): void {\n        const self = this as TemplateRule; // Cast self\n\n        lazyScope.elementArray.forEach(function (\n          ele: { childTarget: any; nonblocking: boolean | number },\n          elementId: number\n        ) {\n          // Retrieve element insertion details from lazy scope\n          const childTarget = ele.childTarget;\n          const nonblocking = ele.nonblocking;\n          // Find the placeholder element\n          const $tmplElement = wrapper.querySelector<TemplateElement>(\n            `template[data-co-tmpl-element-id=\"${elementId}\"]`\n          );\n          // Perform the element insertion\n          if (!$tmplElement) {\n            if (configs.debug)\n              console.warn(\n                `Element insertion placeholder not found for ID ${elementId} in template ${component.tmplId}`\n              );\n            return;\n          }\n          if (!$tmplElement.parentNode) {\n            if (configs.debug)\n              console.warn(\n                `Element insertion placeholder for ID ${elementId} in template ${component.tmplId} has no parent.`\n              );\n            return;\n          }\n\n          const doFunc = function () {\n            if (!$tmplElement || !$tmplElement.parentNode) {\n              if (configs.debug)\n                console.warn(\n                  `Placeholder for ID ${elementId} removed before insertion in template ${component.tmplId}.`\n                );\n              return;\n            }\n\n            // Handle different types of childTarget for insertion\n            try {\n              if (childTarget instanceof Array) {\n                const docFragment = document.createDocumentFragment();\n                childTarget.forEach(function (child: any) {\n                  if (!child) return;\n                  const childElement = child.element || child;\n                  let nodeToAppend: Node | null = null;\n                  // Convert child to a DOM node if necessary\n\n                  if (\n                    typeof childElement === \"string\" ||\n                    typeof childElement === \"number\"\n                  ) {\n                    nodeToAppend = stringToElement(childElement);\n                  } else if (typeof childElement === \"function\") {\n                    nodeToAppend = stringToElement(childElement());\n                  } else if (childElement instanceof Node) {\n                    nodeToAppend = childElement;\n                  } else {\n                    if (configs.debug)\n                      console.warn(\n                        `Invalid item type in element array for ID ${elementId}, template ${component.tmplId}:`,\n                        childElement\n                      );\n                    return;\n                  }\n                  // Append the node to the document fragment\n                  if (child.beforeAppendTo) {\n                    try {\n                      child.beforeAppendTo();\n                    } catch (e) {\n                      console.error(\"Error in beforeAppendTo (array item):\", e);\n                    }\n                  }\n                  if (nodeToAppend) docFragment.appendChild(nodeToAppend);\n                });\n                // Replace the placeholder with the document fragment\n                $tmplElement.parentNode.replaceChild(docFragment, $tmplElement);\n\n                // Call afterAppendTo for each child\n                childTarget.forEach(function (child: any) {\n                  if (child && child.afterAppendTo) {\n                    setTimeout(() => {\n                      try {\n                        child.afterAppendTo();\n                      } catch (e) {\n                        console.error(\n                          \"Error in afterAppendTo (array item):\",\n                          e\n                        );\n                      }\n                    }, 0);\n                  }\n                });\n                // Handle string, number, or function types\n              } else if (\n                typeof childTarget === \"string\" ||\n                typeof childTarget === \"number\"\n              ) {\n                $tmplElement.parentNode.replaceChild(\n                  stringToElement(childTarget),\n                  $tmplElement\n                );\n                // Handle function type\n              } else if (typeof childTarget === \"function\") {\n                $tmplElement.parentNode.replaceChild(\n                  stringToElement(childTarget()),\n                  $tmplElement\n                );\n                // Handle Node or ComponentScope types\n              } else if (\n                childTarget &&\n                (childTarget.element || childTarget) instanceof Node\n              ) {\n                const childScope = childTarget as ComponentScope; // Assume it might be a scope\n                const childElement = childScope.element || childScope;\n\n                // Replace the placeholder with the child element\n                if (childScope.beforeAppendTo) {\n                  try {\n                    childScope.beforeAppendTo();\n                  } catch (e) {\n                    console.error(\"Error in beforeAppendTo:\", e);\n                  }\n                }\n                $tmplElement.parentNode.replaceChild(\n                  childElement,\n                  $tmplElement\n                );\n                // Call afterAppendTo if available\n                if (childScope.afterAppendTo) {\n                  setTimeout(() => {\n                    try {\n                      if (childScope.afterAppendTo) childScope.afterAppendTo();\n                    } catch (e) {\n                      console.error(\"Error in afterAppendTo:\", e);\n                    }\n                  }, 0);\n                }\n                // Set parentComponent if it's a component\n                if (childScope.tmplId) {\n                  childScope.parentComponent = component;\n                }\n                // Handle invalid target types\n              } else {\n                if (configs.debug)\n                  console.warn(\n                    `Invalid target for element insertion ID ${elementId}, template ${component.tmplId}:`,\n                    childTarget\n                  );\n                $tmplElement.parentNode.removeChild($tmplElement);\n              }\n            } catch (e: any) {\n              console.error(\n                `Error during element insertion for ID ${elementId}, template ${component.tmplId}:`,\n                e\n              );\n              if (configs.throwError) throw e;\n              if ($tmplElement && $tmplElement.parentNode) {\n                try {\n                  $tmplElement.parentNode.removeChild($tmplElement);\n                } catch (removeError) {\n                  /* Ignore */\n                }\n              }\n            } // end try\n          }; // end doFunc\n\n          nonblocking === undefined || nonblocking === false\n            ? // Execute immediately or with a delay based on nonblocking\n              doFunc()\n            : setTimeout(\n                doFunc,\n                typeof nonblocking === \"number\" ? nonblocking : 0\n              );\n        }); // end forEach\n      },\n    },\n    lazyEvaluate: {\n      pattern: /###([\\s\\S]+?)##/g,\n      exec: function (lazyEvaluate: string): string {\n        const source = `';\\n__lazyScope.lazyEvaluateArray.push(function(data) {${lazyEvaluate}});\\n__p+='`;\n        // Store the lazy evaluation function in lazy scope\n        return source;\n      },\n      lazyExec: function (\n        data: Record<string, any>,\n        lazyScope: LazyScope,\n        component: ComponentScope,\n        wrapper: DocumentFragment | Element\n      ): void {\n        // Execute stored lazy evaluation functions\n        const $childTarget = firstElementChild(wrapper);\n        const $targetElement =\n          childElementCount(wrapper) === 1 ? $childTarget : null;\n        lazyScope.lazyEvaluateArray.forEach(function (\n          selectedFunc: (data: Record<string, any>) => void,\n          idx: number\n        ) {\n          // Call the function with the appropriate context\n          try {\n            selectedFunc.call($targetElement || wrapper, data); // Use wrapper if multiple elements\n          } catch (e: any) {\n            console.error(\n              `Error in lazyEvaluate block ${idx} for template ${component.tmplId}:`,\n              e,\n              selectedFunc\n            );\n            if (configs.throwError) throw e;\n          }\n        });\n        return;\n      },\n    },\n    evaluate: {\n      pattern: /##([\\s\\S]+?)##/g,\n      exec: (evaluate: string): string => {\n        // Insert arbitrary JavaScript code into the template function\n        return \"';\\n\" + evaluate + \"\\n__p+='\";\n      },\n    },\n    escapeSyntax: {\n      pattern: /#\\\\#([\\s\\S]+?)#\\\\#/g,\n      exec: function (syntax) {\n        return `'+\\n'##${syntax}##'+\\n'`;\n      },\n    },\n  },\n  keys: {\n    dataKeyName: \"data\",\n    statusKeyName: \"status\",\n    componentKeyName: \"component\",\n    i18nKeyName: \"i18n\",\n  },\n});\n\nexport { defaultTemplateEngine };\n","import { CompomintGlobal } from \"./type\";\n\nconst applyBuiltInTemplates = (addTmpl: CompomintGlobal[\"addTmpl\"]): void => {\n  // co-Ele is a shorthand for co-Element, it will generate a div element with the given props and event\n  addTmpl(\n    \"co-Ele\",\n    `<##=data[0]##></##=data[0]##>###compomint.tools.applyElementProps(this, data[1]);##`\n  );\n  addTmpl(\n    \"co-Element\",\n    `##\n  data.tag = data.tag || 'div';\n  ##\n  &lt;##=data.tag##\n    ##=data.id ? 'id=\"' + (data.id === true ? component._id : data.id) + '\"' : ''##\n    data-co-props=\"##:data.props##\"\n    data-co-event=\"##:data.event##\"&gt;\n    ##if (typeof data.content === \"string\") {##\n    ##=data.content##\n    ##} else {##\n      ##%data.content##\n    ##}##\n  &lt;/##=data.tag##&gt;`\n  );\n};\n\nexport { applyBuiltInTemplates };\n"],"names":["firstElementChild","ele","children","childNodes","i","size","length","Element","childElementCount","Array","prototype","filter","call","child","cleanNode","node","n","nodeType","test","nodeValue","removeChild","domParser","DOMParser","stringToElement","str","isNaN","Number","document","createTextNode","String","body","parseFromString","firstChild","fragment","createDocumentFragment","appendChild","e","Object","assign","defineProperty","value","target","params","TypeError","to","index","nextSource","nextKey","hasOwnProperty","writable","configurable","CharacterData","DocumentType","forEach","item","enumerable","this","parentNode","window","Node","get","contains","compomint","tmpl","tools","configs","printExecTime","debug","throwError","cachedTmpl","tmplCache","Map","has","set","elements","Set","isSupportTemplateTag","createElement","noMatch","escapes","escaper","templateEngine","rules","style","pattern","exec","dumy","innerHTML","styleNode","content","querySelector","id","oldStyleNode","getElementById","_a","head","commentArea","preEvaluate","tmplId","Function","console","error","name","message","warn","interpolate","escape","elementProps","props","lazyExec","data","lazyScope","component","wrapper","elementPropsArray","eventId","$elementTrigger","dataset","coProps","keys","key","setAttribute","namedElement","namedElementArray","coNamedElement","elementRef","elementRefArray","func","coElementRef","elementLoad","elementLoadSplitArray","split","elementLoadArray","coLoad","loadFunc","loadFuncParams","element","customData","event","eventStrArray","source","eventArray","eventSplitArray","push","join","self","attacher","selectedArray","coEvent","selected","eventFunc","isArray","trigger","eventName","customEvent","Event","bubbles","cancelable","dispatchEvent","eventData","$childTarget","$targetElement","eventFuncParams","componentElement","parentElement","eventListener","stopPropagation","addEventListener","toString","eventMap","triggerName","eventType","selectedEventFunc","elementSplitArray","elementArray","elementId","childTarget","nonblocking","$tmplElement","doFunc","docFragment","childElement","nodeToAppend","beforeAppendTo","replaceChild","afterAppendTo","setTimeout","childScope","parentComponent","removeError","undefined","lazyEvaluate","lazyEvaluateArray","selectedFunc","idx","evaluate","escapeSyntax","syntax","dataKeyName","statusKeyName","componentKeyName","i18nKeyName","defaultTemplateEngine","escapeHtml","escapeMap","unescapeMap","reduce","acc","createEscaper","map","match","replace","testRegexp","RegExp","replaceRegexp","string","unescape","matcherFunc","templateRules","patternArray","execArray","lazyExecMap","lazyScopeSeed","templateRule","arrayKey","lazyExecKeys","JSON","stringify","escapeFunc","defaultMatcher","templateBuilder","template","templateText","customTemplateEngine","matcher","text","time","offset","selectedMatchContent","slice","matchIndex","some","timeEnd","templateParser","sourceGenFunc","renderingFunc","wrapperElement","callback","baseComponent","firstArg","$wrapperElement","$callback","$baseComponent","parse","status","newComponent","remove","spacer","beforeRemove","selectedEvent","removeEventListener","parent","removedElement","afterRemove","appendTo","release","render","newData","refresh","reflashData","reflash","_id","genId","hasParent","temp","returnTarget","renderedHTML","i18n","log","createComment","tagName","from","host","shadow","attachShadow","mode","$props","prop","startsWith","camelCased","substring","g","toUpperCase","normalize","liveReloadSupport","getOwnPropertyNames","keepProps","includes","currentComponent","targetElement","tmplFunc","hooks","beforeRefresh","afterRefresh","currentData","tmplMeta","tmplIdNames","group","groupObj","part","charAt","remapTmpl","json","oldKey","newKey","meta","safeTemplate","encodedSource","addTmpl","addTmpls","removeInnerTemplate","container","querySelectorAll","coLoadScript","addTmplByUrl","importData","option","defaultOptions","loadScript","loadStyle","loadLink","mergedOptions","appendElements","oldElement","loadResource","dataItem","Promise","resolve","reject","parsedData","obj","url","src","currentOption","endsWith","script","genElement","async","Error","link","type","rel","href","requestFunc","templateContainer","links","styles","scripts","executableScripts","nodeName","scriptElm","getAttributeNames","getAttribute","textContent","importFunc","operationPromise","all","then","catch","err","xmlhttp","XMLHttpRequest","onreadystatechange","readyState","DONE","responseText","statusText","onerror","ontimeout","method","open","timeout","headers","setRequestHeader","send","addI18n","fullKey","i18nObj","langKeyNames","keyLength","lang","subKey","defaultText","documentElement","label","addI18ns","i18nObjs","targetCache","getTargetPath","keyParts","isTranslationObject","processNested","keyPath","finalKey","pop","itemKey","itemValue","itemPath","elementCount","applyElementProps","attrs","propName","toLowerCase","actualAttrs","unshift","concat","propsObjects","mergedProps","propStrArray","escapedValue","applyBuiltInTemplates"],"mappings":"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"}